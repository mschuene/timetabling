#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  de
#+OPTIONS:   H:3 num:t toc:t :nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: vienw:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+TITLE:
#+TAGS:  BlowerDoor(b) Suub(s) Uni(u) Home(h) Task(t) Note(n) Info(i)
#+TAGS: Changed(c) Project(p) Reading(r) Hobby(f) OpenSource(o) Meta(m)
#+SEQ_TODO: TODO(t) STARTED(s) WAITING(w) APPT(a) NEXT(n) MAYBE | DONE(d) CANCELLED(c) DEFERRED(f)
#+STARTUP:content
#+PROPERTY: header-args :results silent :exports none
#+STARTUP: hideblocks
#+OPTIONS: toc:nil titel:nil
#+BIND: org-export-latex-title-command ""
#+LaTeX_CLASS: bachelorarbeit
#+BEGIN_LaTeX latex :exports results
\pagenumbering{roman}

\begin{titlepage}
  \vspace*{6mm}
  \begin{center}
     {\afont Automatische Stundenplanerzeugung mittels Weigthed Partial MAX-SAT}
     \\[3.5cm]
     {\large von}
     \\[3.5cm]
     \Large \textbf{Maik Schünemann}
     \\[2cm]
     {\large Bachelorarbeit in Informatik \/\\
        vorgelegt dem Fachbereich FB 3 \/\\
        der Universität Bremen \/\\
        am }
   \end{center}
   \vfill
   1. Gutachter: Dr. Karsten Hölscher\\
   2. Gutachter: Prof. Dr. Rolf Drechsler\\
   \vfill
\end{titlepage}

\thispagestyle{empty}
Ich versichere, dass ich die Arbeit selbstständig verfasst und keine
anderen als die angegebenen Quellen und Hilfsmittel benutzt sowie
Zitate kenntlich gemacht habe.
\\
\\[3.5cm]
Bremen, den [Datum] [Unterschrift]
\vfill
\noindent
Maik Schünemann\\
Kirchbachstraße 201a, 28211 Bremen\\
{\tt maikschuenemann@gmail.com}

\renewcommand\contentsname{Inhaltsverzeichnis}
\renewcommand\figurename{Abbildung}
\renewcommand\tablename{Tabelle}
\tableofcontents
\clearpage

\mainmatter
\sloppy
#+END_LaTeX
* Einführung
  Ziel dieser Bachelorarbeit ist es, ein Programm zur automatischen
  Stundenplanerzeugung zu erstellen, welches mit der besonderen
  Problemstellung der Grundschule Oslebshausen umgehen kann.    
  
  Bei dem im WiSe 2014/2015 stattgefundenen Softwareprojekt 2 an der
  Universität Bremen wurde für diese Grundschule ein Programm zur
  /manuellen/ Stundenplanerzeugung entwickelt. Anforderungen an das
  Programm waren unter anderem die visuelle Darstellung von harten und
  weichen Problemen bei dem derzeitig eingegebenen Stundenplan. Die
  automatische Erzeugung eines Stundenplans wurde als optionale
  Anforderung gestellt.

  Der hier vorgestellte Ansatz zur automatischen Stundenplanerzeugung
  übersetzt die Anforderungen an einen zulässigen Stundenplan in eine
  aussagenlogische Formel. Für diese Formel wird durch Zuhilfenahme
  von SAT-Solvern entschieden, ob sie erfüllbar ist, und in dem Fall
  eine Variablenzuweisung ermittelt, für die die Formel erfüllt ist.
  Der Stundenplan lässt sich anschließend aus der Variablenzuweisung
  extrahieren.

  Außerdem können Anforderungen nicht nur an einen zulässigen, sondern
  auch an einen möglichst optimalen Stundenplan gestellt werden. Diese
  werden dann zu Formeln übersetzt, die mit einer gewissen Gewichtung
  versehen sind. Diese Formeln, sowie die für einen zulässigen
  Stundenplan, werden einem Partial Max-SAT Solver übergeben, welcher
  nach einer Variablenzuweisung sucht, die alle notwendigen Formeln
  erfüllt und die Summe aller Gewichte der unerfüllten Formeln für die
  Optimalitätsbedingungen minimiert.

  Die gestellten Mindestanforderungen des SWPII Projektes reflektieren
  die bekannten Besonderheiten der Grundschule Oslebshausen. Die für
  die automatische Erstellung eines Stundenplans zu beachtenden
  Anforderungen sind dabei:

  - Die Grundschule hat mehrere Gebäude, die über mehrere Standorte
    verteilt sind, zwischen denen Wegzeiten eingeplant werden müssen,
    sowie für einen optimalen Stundenplan minimiert werden sollen.
  - Raumstabilität kann nicht garantiert werden, was bedeutet, dass
    jedem Stattfinden einer Veranstaltung ein Raum zugewiesen werden
    muss.
  - Die Grundschule hat ein Konzept von Bandunterricht, welches
    bedeutet, dass an einer Veranstaltung mehrere Klassen und Lehrer
    teilnehmen können. Dieses Konzept soll möglichst gut unterstützt
    werden.
  - Lehrer können zu gewissen Zeiten nicht verfügbar sein und dürfen
    zu diesen keine Einträge in ihrem Stundenplan haben.
    Dies darf als weiche Bedingung angesehen werden.
  - Gewisse Fächer können nur in bestimmten Räumen unterrichtet werden.
  - Neben der Darstellung von zeitlichen Lücken des Personals und der
    Notwendigkeit des Pendelns zwischen Standorten soll ein geeignetes
    Maß der Rhythmisierung des Unterrichtes aufgestellt werden.

  Im Verlauf der Arbeit wird an den entsprechenden Stellen auf die
  Umsetzung dieser Besonderheiten eingegangen.

  Das Vorgehen dieser Arbeit richtet sich nach den Ansätzen in
  [[cite:ttpsat]] und [[cite:card]]. Dabei wird das Vorgehen von [[cite:ttpsat]]
  auf die oben formulierten Besonderheiten angepasst.

  #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
    (ns timetabling.core
      (:require [timetabling.cardinality :refer :all]
                [timetabling.logic :refer :all]
                [clojure.test :refer :all]
                [clojure.set :as set]
                [clojure.java.shell :as sh]
                [seesaw.core :refer :all]))
  #+end_src
** Problemformulierung
   Das Problem, einen /zulässigen/ Stundenplan zu erstellen, kann wie
   folgt formuliert werden:

   Aus einer gegebenen Menge an zu verplanenden Vorkommen von
   Veranstaltungen (im folgenden /Events/ genannt) an der eine oder
   mehrere Klassen in einem oder mehreren Räumen eines Gebäudes unter
   dem Unterricht von einem oder mehreren Lerern teilnehmen, einer
   Menge von verfügbaren Zeiten zur Stundenplanung, sowie einer Menge
   von Zeiten, an denen eine bestimmte Klasse, ein Raum oder ein
   Lehrer nicht erreichbar sind, muss eine Zuweisung dieser Events zu
   den Zeiten und Räumen erfolgen, sodass
   die folgenden Einschränkungen erfüllt sind:
   - Kein Lehrer, Klasse oder Raum darf zu einer Zeit von mehreren Events belegt sein.
   - Kein Lehrer, Klasse oder Raum darf zu einer Zeit belegt sein, in
     der er/sie/es nicht verfügbar ist.
   - Jedem zu verplanenden Event muss ein Zeitslot der gebrauchten
     Länge sowie die teilnehmenden Klassen und Lehrer zugewiesen
     werden.
   - Jeder Lehrer und jede Klasse muss zwischen zwei Events an einem
     Tag genug Zeit haben, um vom Standort des ersten zum Standort des
     zweiten zu gelangen.

   Für einen /optimalen/ Stundenplan wird hier zusätzlich gefordert
   - Lehrer und Klassen sollen möglichst wenig zeitliche Lücken
     in ihrem Stundenplan haben.
   - Lehrer und Klassen sollen möglichst wenig zwischen
     verschiedenen Gebäuden innerhalb eines Tages wechseln müssen.
     Dabei werden die Gebäudewechsel mit der assoziierten Wegzeit
     gewichtet.

     Wahlweise kann bei einem zulässigen Stundenplan die Einschränkung
     der Verfügbarkeit von Lehrern fallen gelassen und nur für einen
     optimalen gefordert werden.

     Auf die in den Mindestanforderungen erwähnte Rhytmisierung des
     Unterrichts wird in dieser Arbeit nicht eingegangen.

     Im nächsten Abschnitt wird eine Einführung in das Problem der
     automatisierten Stundenplanerzeugung gegeben, auf relevante
     Ansätze und Literatur verwiesen und der in dieser Arbeit
     eingeschlagende Ansatz, den Stundenplan mithilfe von
     Weigted Partial-MAXSAT Solvern zu erstellen, verteidigt.

     Anschließend wird eine Einführung in das SAT, beziehungsweise
     Weighted Partial MAX-SAT Problem gegeben. Betont wird dabei auch
     der Bedarf einer effizienten Kodierungen von nicht direkt in
     Aussagenlogik ausdrückbaren Bedingungen, wie zum Beispiel
     Kardinalitätsbedingungen (von den Variablen $(a_i)_{i \in I}$
     dürfen höchstens/mindestens/exakt $c$ \texttt{true} sein).

     Die in dieser Arbeit genutzte Kodierung der
     Kardinalitätsbedingungen, die von [[cite:card]] vorgestellt wurde,
     wird im darauffolgendem Abschnitt beschrieben.

     Nach diesen Vorbereitungen wird die Übersetzung der Bedingungen
     für einen zulässigen, bzw. optimalen Stundenplan zu einer
     aussagenlogischen Formel in konjunktiver Normalform beschrieben.
     Dabei wird zunächst ein einfacheres Teilproblem, in dem die Räume
     aller Events schon bekannt sind, betrachtet und untersucht, ob
     dieses für ein Beispiel realistischer Größe effizient lösbar ist.

     Verwendet werden für einen zulässigen Stundenplan SAT4J
     [[cite:sat4j]] und für einen optimalen Stundenplan Open-WBO
     [[cite:openwbo]], welcher mehrere Auszeichnungen in der MAX-SAT
     Evaluation 2014 [[cite:maxsatevaluation2014]] gewonnen hat.

     Dabei wird zunächst nur ein zulässiger Stundenplan erzeugt, die
     Ergebnisse an einem Beispielproblem diskutiert und danach die
     Übersetzung der Bedingungen an einem optimalen Stundenplan
     vorgestellt und evaluiert.

     Die Änderungen der Übersetzungen zur Aussagenlogik für das
     erweiterte Problem, in dem auch die Räume der einzelnen Events
     verplant werden müssen, wird darauffolgend beschrieben und
     evaluiert.

     Abschließend wird ein Fazit gezogen und ein Ausblick gegeben, wie
     das hier beschriebene Programm weiterentwickelt werden könnte.
* Bestehende Ansätze für die automatische Stundenplanerzeugung
  Eine gute Einführung in das Problem der automatischen Stundenplanung
  ist in [[cite:stundenplanerzeugung]] zu finden. Neben dem in
  [[cite:stundenplanerzeugung]] beschriebenen Ansatz durch constraint
  basierte Programmierung werden auch andere, wie heuristische Suche
  [[cite:heuristisch]] oder genetische Algorithmen [[cite:genetisch]] 
  angewendet.

  Bei dem Ansatz durch genetische Algorithmen in [[cite:genetisch]] werden
  Stundenpläne als Individuen einer Population dargestellt, welche am
  Anfang zufällig erzeugt und dann mittels genetischen Operatoren und
  anhand einer Gewichtsfunktion /entwickelt/ werden. Bei der verwendeten
  Gewichtsfunktion (objective function) handelt es sich um eine
  Linearkombination von unter anderem der Nummer von nicht erfüllten
  Bedingungen und verschiedenen Angaben über die Unzufriedenheit von
  Lehrern ob Lücken in ihrem Stundenplan. Eine viel
  größere Gewichtung der Anzahl nicht erfüllter Bedingungen soll dazu
  führen, dass zuallererst versucht wird, zulässige Stundenpläne zu
  generieren bevor die Optimalitätsbedingungen berücksichtigt werden.

  Der in [[cite:stundenplanerzeugung]] beschriebene Ansatz mittels
  constraint basierter Programmierung ist dem hier beschriebenen
  Ansatz ähnlich, allerdings sind die schon vordefinierten constraints
  aussagekräftiger. So sind zum Beispiel Kardinalitätsbedingungen
  bereits integriert. Andererseits ist es bei diesem Ansatz nötig,
  Heuristiken anzugeben, mit welcher Priorität zwischen
  unterschiedlichen Zuweisungsmöglichkeiten verschiedener Variablen
  gewählt wird, während dies beim hier gewählten Ansatz nicht nötig
  ist. In [[cite:stundenplanerzeugung]] wird eine Heuristik basierend auf
  der Priorität des dazugehörigen Faches beschrieben.

  Diese Arbeit basiert auf dem Vorgehen beschrieben in [[cite:ttpsat]], in
  dem ein SAT-, beziehungsweise MAX-SAT (genauer Weighted Partial
  MAX-SAT) Solver genutzt wird, um eine zum speziellen
  Stundenplanproblem äquivalente logische Formel in aussagenlogischer
  konjunktiver Normalform (partiell) zu lösen und daraus den
  Stundenplan zu erzeugen.

  Dieser Ansatz wurde an öffentlich zugänglichen Problemen evaluiert.
  Das folgende Zitat stammt aus dem Abstract von [[cite:ttpsat]].

  #+BEGIN_quote
  Out of 32 standard benchmark instances derived from the Second
  International Timetabling Competition held in 2007, our techniques
  yield the best known solutions for 21 of them (19 of them being
  optimal), improving the previously best known solutions for 9. In
  addition, we obtain 18 new lower bounds for this benchmark set by
  applying a new full (Weighted) Partial MaxSAT approach of the
  Curriculum-based Course Timetabling problem.
  #+END_quote

  Gegenüber Ansätzen mittels constraint basierter Programmierung hat
  der Ansatz den Vorteil, dass keine Heuristiken der
  Variablenzuweisung angegeben werden müssen, da dieses vom SAT-Solver
  automatisch anhand der logischen Beziehungen der Variablen der zu
  lösenden logischen Formel vorgenommen wird, und hat dafür den Nachteil,
  dass es schwerer ist, die Bedingungen auf eine aussagenlogische
  Formel abzubilden, als mittels einem constraint-basierten Systems.

  Der SAT, beziehungsweise MAX-SAT basierte Ansatz ist auch deshalb
  sehr ansprechend, da durch die eingesetzten Solver ebenfalls mit
  angegeben wird, ob es sich bei der gefundenen Lösung um ein
  globales Optimum handelt.

*  Einführung in das SAT und MAXSAT Problem

** SAT Problem
   Bei SAT Problem handelt es sich um das Erfüllbarkeitsproblem der
   Aussagenlogik. Gegeben einer aussagenlogischer Formel in
   konjunktiver Normalform wird ihre Erfüllbarkeit ermittelt. Im
   Folgenden werden diese Konzepte kurz beschrieben.
*** Aussagenlogik

    Eine Formel in Aussagenlogik setzt sich zusammen aus
    - Literalen, welche entweder Variablen sind, oder negierte
      Variablen. Dabei wird die Negation einer Variable $V$ mit $\neg
      V$ bezeichnet. Die Negation einer Variable ist genau dann \texttt{true},
      wenn die Variable selbst \texttt{false} ist.
    - eine Konjunktion $a \wedge b$ ist genau dann \texttt{true}, wenn sowohl
      $a$ als auch $b$ \texttt{true} sind
    - eine Disjunktion $a \vee b$ ist genau dann \texttt{false}, wenn
      sowohl $a$ als auch $b$ \texttt{false} sind

    Ein Beispiel für eine Formel in der Aussagenlogik ist

    \[(a \vee b) \wedge \neg c\]

    Die De-Morganschen Gesetze geben gültige Umformungen von
    aussagenlogischen Formeln an.

    \begin{align*}
    \neg (a \wedge b) &= \neg a \vee \neg b \\
    \neg (a \vee b) &= \neg a \wedge \neg b \text{ .}\\
    \end{align*}

    Außerdem gilt
    \[\neg \neg a = a \text{ .}\]

    Mithilfe dieser Umformungen kann man Normalformen definieren, in
    die jede aussagenlogische Formel durch Anwendung der Umformungen
    gebracht werden kann. Für das Erfüllbarkeitsproblem hat dies den
    Vorteil, dass nur Formeln in dieser Normalform betrachtet werden
    müssen. Für das SAT Problem wird dafür üblicherweise die
    konjunktive Normalform benutzt, auf welche im folgenden Abschnitt
    eingegangen wird.

*** Konjunktive Normalform

    Eine aussagenlogische Formel befindet sich in konjunktiver
    Normalform, wenn sie als Konjunktion von Disjunktionen geschrieben
    werden kann, bzw sie die in [[ref:konjnorm]] skizzierte Form hat,
    wobei jedes $x_{i,i}$ entweder eine Variable oder eine negierte
    Variable ist, sowie $I, J_i$ endliche Indexmengen sind.

    \begin{align}
    \label{konjnorm}
    \bigwedge_{i \in I} \bigvee_{j \in J_i} x_{i,j}
    \end{align}

    Jede vorkommende Disjunktion $\bigvee_{j \in J_i} x_{i,j}$ wird dabei als
    Klausel bezeichnet.



*** Prädikatenlogik erster Stufe
    Die Bedingungen an einen zulässigen und optimalen Stundenplan
    lassen sich in natürlicher Weise in der Prädikatenlogik erster Stufe formulieren.
    Im Gegensatz zur Aussagenlogik sind weitergehend die Quantoren $\exists,
    \forall$ erlaubt, sowie logische Prädikate.

    Bei den folgenden Beschreibungen der Kodierung der Bedingungen
    eines Stundenplans in Aussagenlogik werden die einzelnen
    Bedingungen zuerst in einer Formel der Prädikatenlogik erster
    Stufe gegeben und daraufhin die vorkommenden Quantoren durch
    Erzeugung der Klausel für alle möglichen Wertekombinationen ihrer
    Variablen aufgelöst und die resultierende aussagenlogische Formel
    in konjunktive Normalform gebracht.

*** Komplexität des SAT Problems
    Das Erfüllbarkeitsproblem der Aussagenlogik gehört zur
    Komplexitätsklasse $NP$, es ist sogar $NP$ vollständig [[cite:satnpcomplete]].

    Auf heutzutage angewendete Lösungsverfahren dieses Problems wird
    in dieser Arbeit nicht näher eingegangen.

    Da der in dieser Arbeit vorgestellte Algorithmus darauf angewiesen
    ist, dass der benutzte SAT-solver in annehmbarer Zeit ein Ergebnis
    zurückliefert, wird das Stundenplanproblem in Stufen aufsteigender
    Komplexität angegegangen und die einzelnen Stufen an einem
    Beispiel repräsentativem Umfangs auf Lösbarkeit in angemessener
    Zeit geprüft, bevor die nächste Stufe beschrieben wird.

    Da die Eingabesprache von SAT nur aus einer Formel in konjunktiver
    Normalform besteht, müssen zum Beispiel Kardinalitätsbedingungen
    auf dieses Format abgebildet werden. Dadurch kann eine
    beträchtliche Menge an zusätzlichen Klauseln erzeugt werden  und
    es ist wichtig, eine effiziente Kodierung für diese
    Bedingungen zu haben. Auf dieses Problem wird in Abschnitt
    [[ref:card]] eingegangen.

** MAX-SAT, Partial MAX-SAT und Weighted Partial MAX-SAT Probleme

   Im Gegensatz zum SAT Problem geht es beim MAX-SAT Problem darum, eine
   Variablenzuweisung zu finden, sodass nicht unbedingt alle, aber
   möglichst viele Klauseln der gegebenen aussagenlogischen Formel in
   konjunktiver Normalform erfüllt sind.

   Wenn dabei eine Untermenge der Klauseln erfüllt bleiben muss (harte Klauseln) und es
   gilt möglichst viele der übrigen Klauseln (weiche Klauseln) durch eine
   Variablenzuweisung zu erfüllen, handelt es sich um ein Partial
   MAX-SAT Problem.

   Beim Weighted Partial MAX-SAT Problem hat jede weiche Klausel
   außerdem ein Gewicht zugeordnet und es geht darum, die Zuweisung zu
   finden, die alle harten Klauseln erfüllt und die Summe der Gewichte
   der nicht-erfüllten weichen Klauseln minimiert.

* Utilities for encoding                                           :noexport:
  Die Parameter des problems werden in einer entity-map verwaltet
 #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
   (def entities
     {:classes []
      :events []
      :rooms []
      :buildings []
      :teachers []
      :num-days 5
      :distances {}
      :hours-per-day 6})

   (defn create-event [& {:keys [classes rooms teachers durations times number-of-times forbidden-rooms]}]
     {:classes (if (seq? classes) classes #{classes})
      :rooms (if rooms (if (and (set? rooms) number-of-times) (vec (repeat number-of-times rooms)) rooms ) (vec (repeat number-of-times nil)))
      :teachers (if (and (set? teachers) number-of-times) (vec (repeat number-of-times teachers)) teachers)
      :durations (if (and (not durations) number-of-times) (vec (repeat number-of-times 1))  durations)
      :forbidden-rooms (or forbidden-rooms #{})
      :times (or times (vec (repeat number-of-times nil)))
      })


   (defn events-to-schedule
     "unfolds events that are to be held multiple times a week"
     [events]
     (for [[n details] events
           idx (range (count (:durations details)))]
       [(keyword (str (name n) ":" idx))
        {:classes (:classes details) :rooms (nth (:rooms details) idx)
         :teachers (nth (:teachers details) idx)
         :duration (nth (:durations details) idx)
         :forbidden-rooms (:forbidden-rooms details)
         :time (nth (:times details) idx)}]))


   (defn next-times-at-day
     "returns the num next [day hour] pairs at that day, possibly less when
      hours-per-day is reached"
     [[day hour] hours-per-day num]
     (map vector (repeat day) (range (inc hour) (min hours-per-day (+ hour num 1)))))

   (defn previous-times-at-day
    [[day hour] num]
    (map vector (repeat day) (range (dec hour) (max -1 (- hour num 1)) -1)))

   (deftest test-next-times-at-day
     (is (= '([2 3] [2 4] [2 5]) (next-times-at-day [2 2] 6 4)))
     (is (= '([2 3]) (next-times-at-day [2 2] 6 1))))

   (test-next-times-at-day)


   (deftest test-previous-times-at-day
     (is (= '([2 2] [2 1])
            (previous-times-at-day [2 3] 4))))

   (test-previous-times-at-day)
 #+end_src


 Dabei haben die einzelnen slots folgende Bedeutungen
 | Name          | Bedeutung                                                        |
 | classes       | Map von Klassen mit :name :class-teacher :class-room             |
 | rooms         | Map von Räumen mit :name :building                               |
 | buildings     | Map von Buildings als Strings                                    |
 | teachers      | Map von Lehrern mit :sid :hours-per-week :times-not-available    |
 | num-days      | Wie viele Tage werden verplant, sollten 5 sein                   |
 | hours-per-day | Wie viele Zeitslots es an einem Wochentag zu verplanen gibt      |
 | events        | Liste von Events mit :classes :rooms :teachers :durations :times |

 dabei ist :classes ein Pflichtfeld in events, :durations ist eine
 Liste von Integern welche angibt, wie viele Veranstaltungen es von
 diesem Event gibt und wie lang jedes ist.
 :teachers und :rooms und :times und :durations können nil sein, was
 bedeutet, dass die Zuweisungen noch gefunden werden müssen oder
 eine vorgegebene Liste, welche dann als feste constraints in der
 Planung übernommen werden. Das Format von :times ist ein tupel mit
 tages index in der ersten Stelle und Zeitindex in der zweiten
 Stelle.

** Einfaches Beispielproblem
   Ein einfaches Beispielproblem, was aber alle Herausforderungen illustriert, ist aufgabaut wie folgt
   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
   (def example-entities {
   #+end_src
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :classes {:class-1 {:class-teacher :teacher-1 :class-room [:building-1 :room-1]}
                 :class-2 {:class-teacher :teacher-2 :class-room [:building-2 :room-1]}}
     #+end_src
   - brauchen 5 Fächer
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :events {
     #+end_src
     - Mathe 4 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :class-1-math
         (create-event :classes :class-1 :rooms #{[:building-1 :room-1]} :teachers #{:teacher-1} :number-of-times 4) ;;hier auf 30 ändern
         :class-2-math
         (create-event :classes :class-2 :rooms #{[:building-2 :room-1]} :teachers #{:teacher-2} :number-of-times 4)
       #+end_src
     - Sachkunde 4 std
      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      :class-1-sk
      (create-event :classes :class-1 :rooms #{[:building-1 :room-1]} :teachers #{:teacher-1} :number-of-times 4)
      :class-2-sk
      (create-event :classes :class-2 :rooms #{[:building-2 :room-1]} :teachers #{:teacher-2} :number-of-times 4)
      #+end_src
     - Deutsch 4 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :class-1-german
       (create-event :classes :class-1 :rooms #{[:building-1 :room-1]} :teachers #{:teacher-1} :number-of-times 4)
       :class-2-german
       (create-event :classes :class-2 :rooms #{[:building-2 :room-1]} :teachers #{:teacher-2} :number-of-times 4)
       #+end_src
     - Sport 2 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :class-1-sport
       (create-event :classes :class-1 :rooms #{[:sporthalle :sporthalle]} :teachers #{:teacher-2} :durations [2] :number-of-times 1)
       :class-2-sport
       (create-event :classes :class-2 :rooms #{[:sporthalle :sporthalle]} :teachers #{:teacher-2} :durations [2] :number-of-times 1)
       #+end_src
     - Kunst 2 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :class-1-art
       (create-event :classes :class-1 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-1} :number-of-times 4)
       :class-2-art
       (create-event :classes :class-2 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-1} :number-of-times 4)
       #+end_src
     - Werken 2 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :class-1-werken
       (create-event :classes :class-1 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-1} :number-of-times 2)
       :class-2-werken
       (create-event :classes :class-2 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-1} :number-of-times 2)
       #+end_src
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       }
       #+end_src
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :buildings {
     #+end_src
     - 1 mit assenraum Klasse1 und Kunstraum
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :building-1 {:room-1 {} :art-room {}}
       #+end_src
     - 1 mit Klassenraum Klasse2 und Werkraum
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :building-2 {:room-1 {} :werkraum {}}
       #+end_src
     - 1 Sporthalle nur Verfügbar am Donnerstag Stunden 1,2,3,4 (wir benutzen 0 basiertes Indexing hier!)
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :sporthalle {:sporthalle
                      {:times-not-available
                       (set/difference (into #{} (for [d (range 5) h (range 5)] [d h]))
                                       #{[3 1] [3 2] [3 3] [3 4]})}}
       #+end_src
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       }
       #+end_src
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :num-days 5
     :hours-per-day 6
     #+end_src
   - 2 Lehrer
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :teachers {:teacher-1 {} :teacher-2 {}}
     #+end_src
     - 1. Lehrer unterrichtet
       - Klassenlehrer Klasse 1
       - Kunst und Werken
     - 2. Lehrer unterrichtet
       - Klassenlehrer Klasse 2
       - Sport
   - Wegstrecke zwischen gebäuden: 1 Freistunde muss man einplanen
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :distances {[:building-1 :building-2] 1
                   [:building-2 :building-1] 1
                   [:building-1 :sporthalle] 1
                   [:sporthalle :building-1] 1
                   [:building-2 :sporthalle] 1
                   [:sporthalle :building-2] 1}
     #+end_src
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         })
         #+end_src


   diesmal mehr klassen lehrer und räume größenordnung schule oslebshausen!
   - 12 Klassen!
   - 12 Lehrer!
   - 12 Klassenräume

   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
   (def bigger-example-entities {
   #+end_src
   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :classes {:class-1 {:class-teacher :teacher-1 :class-room [:building-1 :room-1]}
                 :class-2 {:class-teacher :teacher-2 :class-room [:building-2 :room-1]}
                 :class-3 {:class-teacher :teacher-3 :class-room [:building-1 :room-2]}
                 :class-4 {:class-teacher :teacher-4 :class-room [:building-2 :room-2]}
                 :class-5 {:class-teacher :teacher-5 :class-room [:building-1 :room-3]}
                 :class-6 {:class-teacher :teacher-6 :class-room [:building-2 :room-3]}
                 :class-7 {:class-teacher :teacher-7 :class-room [:building-1 :room-4]}
                 :class-8 {:class-teacher :teacher-8 :class-room [:building-2 :room-4]}
                 :class-9 {:class-teacher :teacher-9 :class-room [:building-1 :room-5]}
                 :class-10 {:class-teacher :teacher-10 :class-room [:building-2 :room-5]}
                 :class-11 {:class-teacher :teacher-11 :class-room [:building-1 :room-6]}
                 :class-12 {:class-teacher :teacher-12 :class-room [:building-2 :room-6]}
                 }
     #+end_src
   - brauchen 5 Fächer
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :events {
     #+end_src
     - Mathe 4 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :class-1-math
         (create-event :classes :class-1 :rooms #{[:building-1 :room-1]} :teachers #{:teacher-1} :number-of-times 4) ;;hier auf 30 ändern
         :class-2-math
         (create-event :classes :class-2 :rooms #{[:building-2 :room-1]} :teachers #{:teacher-2} :number-of-times 4)
         :class-3-math
         (create-event :classes :class-3 :rooms #{[:building-1 :room-2]} :teachers #{:teacher-3} :number-of-times 4) ;;hier auf 30 ändern
         :class-4-math
         (create-event :classes :class-4 :rooms #{[:building-2 :room-2]} :teachers #{:teacher-4} :number-of-times 4)
         :class-5-math
         (create-event :classes :class-5 :rooms #{[:building-1 :room-3]} :teachers #{:teacher-5} :number-of-times 4) ;;hier auf 30 ändern
         :class-6-math
         (create-event :classes :class-6 :rooms #{[:building-2 :room-3]} :teachers #{:teacher-6} :number-of-times 4):class-7-math
         (create-event :classes :class-7 :rooms #{[:building-1 :room-4]} :teachers #{:teacher-7} :number-of-times 4) ;;hier auf 30 ändern
         :class-8-math
         (create-event :classes :class-8 :rooms #{[:building-2 :room-4]} :teachers #{:teacher-8} :number-of-times 4)
         :class-9-math
         (create-event :classes :class-9 :rooms #{[:building-1 :room-5]} :teachers #{:teacher-9} :number-of-times 4) ;;hier auf 30 ändern
         :class-10-math
         (create-event :classes :class-10 :rooms #{[:building-2 :room-5]} :teachers #{:teacher-10} :number-of-times 4):class-11-math
         (create-event :classes :class-11 :rooms #{[:building-1 :room-6]} :teachers #{:teacher-11} :number-of-times 4) ;;hier auf 30 ändern
         :class-12-math
         (create-event :classes :class-12 :rooms #{[:building-2 :room-6]} :teachers #{:teacher-12} :number-of-times 4)
       #+end_src
     - Sachkunde 4 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :class-1-sk
         (create-event :classes :class-1 :rooms #{[:building-1 :room-1]} :teachers #{:teacher-1} :number-of-times 4)
         :class-2-sk
         (create-event :classes :class-2 :rooms #{[:building-2 :room-1]} :teachers #{:teacher-2} :number-of-times 4)
         :class-3-sk
         (create-event :classes :class-3 :rooms #{[:building-1 :room-2]} :teachers #{:teacher-3} :number-of-times 4)
         :class-4-sk
         (create-event :classes :class-4 :rooms #{[:building-2 :room-2]} :teachers #{:teacher-4} :number-of-times 4)
         :class-5-sk
         (create-event :classes :class-5 :rooms #{[:building-1 :room-3]} :teachers #{:teacher-5} :number-of-times 4)
         :class-6-sk
         (create-event :classes :class-6 :rooms #{[:building-2 :room-3]} :teachers #{:teacher-6} :number-of-times 4)
         :class-7-sk
         (create-event :classes :class-7 :rooms #{[:building-1 :room-4]} :teachers #{:teacher-7} :number-of-times 4)
         :class-8-sk
         (create-event :classes :class-8 :rooms #{[:building-2 :room-4]} :teachers #{:teacher-8} :number-of-times 4)
         :class-9-sk
         (create-event :classes :class-9 :rooms #{[:building-1 :room-5]} :teachers #{:teacher-9} :number-of-times 4)
         :class-10-sk
         (create-event :classes :class-10 :rooms #{[:building-2 :room-5]} :teachers #{:teacher-10} :number-of-times 4)
         :class-11-sk
         (create-event :classes :class-11 :rooms #{[:building-1 :room-6]} :teachers #{:teacher-11} :number-of-times 4)
         :class-12-sk
         (create-event :classes :class-12 :rooms #{[:building-2 :room-6]} :teachers #{:teacher-12} :number-of-times 4)
       #+end_src
     - Deutsch 4 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :class-1-german
         (create-event :classes :class-1 :rooms #{[:building-1 :room-1]} :teachers #{:teacher-1} :number-of-times 4)
         :class-2-german
         (create-event :classes :class-2 :rooms #{[:building-2 :room-1]} :teachers #{:teacher-2} :number-of-times 4)
         :class-3-german
         (create-event :classes :class-3 :rooms #{[:building-1 :room-2]} :teachers #{:teacher-3} :number-of-times 4)
         :class-4-german
         (create-event :classes :class-4 :rooms #{[:building-2 :room-2]} :teachers #{:teacher-4} :number-of-times 4)
         :class-5-german
         (create-event :classes :class-5 :rooms #{[:building-1 :room-3]} :teachers #{:teacher-5} :number-of-times 4)
         :class-6-german
         (create-event :classes :class-6 :rooms #{[:building-2 :room-3]} :teachers #{:teacher-6} :number-of-times 4)
         :class-7-german
         (create-event :classes :class-7 :rooms #{[:building-1 :room-4]} :teachers #{:teacher-7} :number-of-times 4)
         :class-8-german
         (create-event :classes :class-8 :rooms #{[:building-2 :room-4]} :teachers #{:teacher-8} :number-of-times 4)
         :class-9-german
         (create-event :classes :class-9 :rooms #{[:building-1 :room-5]} :teachers #{:teacher-9} :number-of-times 4)
         :class-10-german
         (create-event :classes :class-10 :rooms #{[:building-2 :room-5]} :teachers #{:teacher-10} :number-of-times 4)
         :class-11-german
         (create-event :classes :class-11 :rooms #{[:building-1 :room-6]} :teachers #{:teacher-11} :number-of-times 4)
         :class-12-german
         (create-event :classes :class-12 :rooms #{[:building-2 :room-6]} :teachers #{:teacher-12} :number-of-times 4)
       #+end_src
     - Sport 2 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :class-1-sport
         (create-event :classes :class-1 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-2-sport
         (create-event :classes :class-2 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-3-sport
         (create-event :classes :class-3 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-4-sport
         (create-event :classes :class-4 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-5-sport
         (create-event :classes :class-5 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-6-sport
         (create-event :classes :class-6 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-7-sport
         (create-event :classes :class-7 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-8-sport
         (create-event :classes :class-8 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-9-sport
         (create-event :classes :class-9 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-10-sport
         (create-event :classes :class-10 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-11-sport
         (create-event :classes :class-11 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
         :class-12-sport
         (create-event :classes :class-12 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
       #+end_src
     - Kunst 2 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :class-1-art
         (create-event :classes :class-1 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-1} :number-of-times 2)
         :class-2-art
         (create-event :classes :class-2 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-2} :number-of-times 2)
         :class-3-art
         (create-event :classes :class-3 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-3} :number-of-times 2)
         :class-4-art
         (create-event :classes :class-4 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-4} :number-of-times 2)
         :class-5-art
         (create-event :classes :class-5 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-5} :number-of-times 2)
         :class-6-art
         (create-event :classes :class-6 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-6} :number-of-times 2)
         :class-7-art
         (create-event :classes :class-7 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-7} :number-of-times 2)
         :class-8-art
         (create-event :classes :class-8 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-8} :number-of-times 2)
         :class-9-art
         (create-event :classes :class-9 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-9} :number-of-times 2)
         :class-10-art
         (create-event :classes :class-10 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-10} :number-of-times 2)
         :class-11-art
         (create-event :classes :class-11 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-11} :number-of-times 2)
         :class-12-art
         (create-event :classes :class-12 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-12} :number-of-times 2)
       #+end_src
     - Werken 2 std
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :class-1-werken
         (create-event :classes :class-1 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-1} :number-of-times 2)
         :class-2-werken
         (create-event :classes :class-2 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-2} :number-of-times 2)
         :class-3-werken
         (create-event :classes :class-3 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-3} :number-of-times 2)
         :class-4-werken
         (create-event :classes :class-4 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-4} :number-of-times 2)
         :class-5-werken
         (create-event :classes :class-5 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-5} :number-of-times 2)
         :class-6-werken
         (create-event :classes :class-6 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-6} :number-of-times 2)
         :class-7-werken
         (create-event :classes :class-7 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-7} :number-of-times 2)
         :class-8-werken
         (create-event :classes :class-8 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-8} :number-of-times 2)
         :class-9-werken
         (create-event :classes :class-9 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-9} :number-of-times 2)
         :class-10-werken
         (create-event :classes :class-10 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-10} :number-of-times 2)
         :class-11-werken
         (create-event :classes :class-11 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-11} :number-of-times 2)
         :class-12-werken
         (create-event :classes :class-12 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-12} :number-of-times 2)
       #+end_src
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       }
       #+end_src
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :buildings {
     #+end_src
     - 1 mit Klassenraum Klasse1 und Kunstraum
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :building-1 {:room-1 {}
                      :room-2 {}
                      :room-3 {}
                      :room-4 {}
                      :room-5 {}
                      :room-6 {}
                      :art-room {}}
       #+end_src
     - 1 mit Klassenraum Klasse2 und Werkraum
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :building-2 {:room-1 {}
                      :room-2 {}
                      :room-3 {}
                      :room-4 {}
                      :room-5 {}
                      :room-6 {}
                      :werkraum {}}
       #+end_src
     - 1 Sporthalle nur Verfügbar am Donnerstag Stunden 1,2,3,4 (wir benutzen 0 basiertes Indexing hier!)
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         :sporthalle {:sporthalle
                      {}}
       #+end_src
       #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       }
       #+end_src
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :num-days 5
     :hours-per-day 6
     #+end_src
   - 2 Lehrer
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       :teachers {:teacher-1 {}
                  :teacher-2 {}
                  :teacher-3 {}
                  :teacher-4 {}
                  :teacher-5 {}
                  :teacher-6 {}
                  :teacher-7 {}
                  :teacher-8 {}
                  :teacher-9 {}
                  :teacher-10 {}
                  :teacher-11 {}
                  :teacher-12 {}
                  :sportlehrer {}}
     #+end_src
     - 1. Lehrer unterrichtet
       - Klassenlehrer Klasse 1
       - Kunst und Werken
     - 2. Lehrer unterrichtet
       - Klassenlehrer Klasse 2
       - Sport
   - distances
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     :distances {[:building-1 :building-2] 1
                            [:building-2 :building-1] 1
                            [:building-1 :sporthalle] 1
                            [:sporthalle :building-1] 1
                            [:building-2 :sporthalle] 1
                            [:sporthalle :building-2] 1}
     #+end_src
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
         })
         #+end_src
* Effizientes Kodieren von Kardinalitätsklauseln in Aussagenlogik
  \label{card} Beim Übersetzen der Bedingungen an einen zulässigen
  Stundenplan kommen sogenannte Kardinalitätsklauseln vor. Zum
  Beispiel kann die Bedingung, dass zur Zeit $t$ höchstens ein Event
  $e$ im Raum $r$ stattfindet, ausgedrückt werden durch
  \[\operatorname{at-most}(1,[\operatorname{occurs-in-room-at-hour}_{r,t}(e_1),\ldots
  ,\operatorname{occurs-in-room-at-hour}_{r,t}(e_n)]) \text{ ,}\]

  wobei die Variable $\operatorname{occurs-in-room-at-hour}_{r,t}(e)$
  angibt, ob das Event $e$ zur Zeit $t$ in Raum $r$ stattfindet.

  Für den speziellen Fall, dass höchstens eine der Variablen \texttt{true} sein darf,
  könnte man die Kardinalitätsbedingung
  $\operatorname{at-most-1(v_1,\ldots, v_n)}$ in die Formel

  \[\bigwedge_{i,j \leq n i \neq j \hspace{3mm}} v_i \Rightarrow \neg v_j = \bigwedge_{i,j \leq n i \neq j \hspace{3mm}} \neg v_i \vee \neg v_j \]

  übersetzen, was der Intuition folgt, dass sobald ein $v_i$ \texttt{true} ist,
  sofort alle anderen \texttt{false} sein müssen.

  Die für $n$ Variablen erzeugte Formel enthält allerdings $n*(n - 1)$
  Klauseln.

  Das quadratische Wachstum dieser Kodierung hat sich aber für die in
  dieser Arbeit benötigten Kardinalitätsbedingungen als nicht
  effizient genug herausgestellt, weshalb in dieser Arbeit eine
  effizientere Art der Übersetzung von Kardinalitätsbedingungen
  $\operatorname{at-most}(k,[v_{1},\ldots,v_{n}])$ in aussagenlogische
  Klauseln durch sogenannte /Cardinality Networks/ [[cite:card]], bei
  denen der Aufwand in $O(n \log^{2} k)$ liegt, genutzt wird.

  Aus Platzgründen wird nur der Ansatz des Algorithmus erläutert, für
  mehr Details wird auf [[cite:card]] verwiesen.

  Die Grundidee des in [[cite:card]] vorgestellten Algorithmus ist es,
  einen Schaltkreis aufzubauen, der $n$ ungeordnete Eingangssignale
  $a_1,\ldots,a_n$ und $n$ geordneten Ausgangssignale $c_1, \ldots ,
  c_n$ hat, in der Art, dass es immer einen Index $j$ gibt, sodass die
  ersten $j$ Ausgänge $c_1,\ldots,c_j$ \texttt{true} und die restlichen
  Ausgänge $c_{j+1},\ldots,c_n$ \texttt{false} sind, umwandelt. Abbildung
  [[ref:fig:sorting-network]] veranschaulicht dies an einem Beispiel.

  #+ATTR_LATEX: :width 250px
  #+LABEL: fig:sorting-network
  #+CAPTION: Kardinalitätsbedingungen durch ein Sortiernetzwerk.
  [[file:images/sorting-network-gimp.png]]



  Kardinalitätsbedingungen lassen sich damit leicht anhand der Ausgänge
  $c_1,\ldots,c_n$ ausdrücken:
  - Für die Bedingung $\operatorname{at-most}(k,[a_1,\ldots,a_n])$ reicht
    es zu fordern, dass der $k + 1$-te Ausgang des Sortiernetzwerkes
    \texttt{false} ist. Es wird also eine Klausel
    \[\neg c_{k + 1}\]
    den das Netzwerk beschreibenden Klauseln hinzugefügt.
  - Für die Bedingung $\operatorname{at-least}(k,[a_1,\ldots,a_n])$ wird
    die Klausel
    \[c_k\]
    gefordert.
  - Für die Bedingung $\operatorname{exactly}(k,[a_1,\ldots,a_n])$ werden die beiden
    Klauseln
    \[\neg c_{k + 1}\]
    \[c_k\]
    gefordert.

  #+ATTR_LATEX: :width 250px
  #+CAPTION: Vereinfachtes Sortiernetzwerk.
  #+LABEL: fig:simplified-sorting-network
  [[file:images/simplified-sorting-network-gimp.png]]



  In vielen praktischen Anwendungen, wie auch dem oben gegebenen
  Beispiel aus der Stundenplanerzeugung, ist of $k < n$, und somit nur
  wenige Ausgänge des Sortiernetzwerkes interessant. In [[cite:card]] wird
  für diesen Fall ein vereinfachtes Sortiernetzwerk konstruiert, das
  $n = m \times k$ Eingänge, wobei $k = 2^r$ und $m \in \mathbb{N}$, und
  $k$ Ausgänge hat. Abbildung [[ref:fig:simplified-sorting-network]] stellt ein solches
  Netzwerk mit 16 Eingängen und 4 Ausgängen dar.

  Durch die Kodierung von Kardinalitätsbedingungen mittels eines
  vereinfachten Sortier-Netzwerkes werden $O(n \log^2{k})$ Klauseln
  und $O(n \log^2{k})$ Hilfsvariablen benötigt [[cite:card]].

** code - encoding cardinality constraints                         :noexport:


   #+begin_src clojure :ns timetabling.cardinality :tangle src/timetabling/cardinality.clj
     (ns timetabling.cardinality
       (:require  [timetabling.logic :refer :all]
                  [clojure.set :refer [union]]))


     ;;not used because at-least-k and exactly-k aren't simple adaptions of
     ;;the formula
     #_(defn at-most-k
       "returns cnf form of the constraint that at most k of the variables
       are true see http://www.carstensinz.de/papers/CP-2005.pdf"
       [xs k]
       (let [n (count xs) ;;convert from 1-based indexing to 0-based
             s (into [] (for [i (range n)]
                          (into [] (for [j (range k)]
                                     (symbol (str "s" i j))))))]
         ((comp flatten concat)
          [#{(gen-var (nth xs 0) false) (gen-var (get-in s [0 0]))}]
          (for [j (range 1 k)]
            #{(gen-var (get-in s [0 j]) false)})
          (for [i (range 1 (dec n))]
            (concat
             [#{(gen-var (nth xs i) false)
                (gen-var (get-in s [i 0]))}
              #{(gen-var (get-in s [(dec i) 0]) false)
                (gen-var (get-in s [i 0]))}]
              (for [j (range 1 k)]
                [#{(gen-var (nth xs i) false)
                   (gen-var (get-in s [(dec i) (dec j)] false))
                   (gen-var (get-in s [i j]))}
                 #{(gen-var (get-in s [(dec i) j]) false)
                   (gen-var (get-in s [i j]))}])
              [#{(gen-var (nth xs i) false)
                  (gen-var (get-in s [(dec i) (dec k)]) false)}]))
          [#{(gen-var (nth xs (dec n)) false)
             (gen-var (get-in s [(- n 2) (dec k)]) false)}])))


     (defn generate-unique-vars
       ([n] (generate-unique-vars n "guv"))
       ([n prfx] (generate-unique-vars n prfx true));;initially set to true?
       ([n prfx b]
         (repeatedly n (comp #(gen-var % b)
                             (partial gensym prfx)))))


     (def base-case-clauses
       {:at-most (fn [a b cs]
                   [#{(negate a) (negate b) (second cs)}
                    #{(negate a) (first cs)}
                    #{(negate b) (first cs)}])
        :at-least (fn [a b cs]
                    [#{a b (negate (first cs))}
                     #{a (negate (second cs))}
                     #{b (negate (second cs))}])
        :between (fn [a b cs]
                   [#{(negate a) (negate b) (second cs)}
                    #{(negate a) (first cs)}
                    #{(negate b) (first cs)}
                    #{a b (negate (first cs))}
                    #{a (negate (second cs))}
                    #{b (negate (second cs))}])})
     ;;(dec n) auf n erhöhen und in h-merge entsprechend anpassen
     ;;s-merge gleichbehalten und damit hoffentlich letzten bug fixen......
     (def recursive-case-clauses
       {:at-most (fn [n cs ds es]
                   (for [i (range n)]
                   [#{(negate (nth ds (inc i)))
                      (negate (nth es i))
                      (nth cs (+ 2 (* 2 i)))}
                    #{(negate (nth ds (inc i)))
                      (nth cs (inc (* 2 i)))}
                    #{(negate (nth es i))
                      (nth cs (inc (* 2 i)))}])) ;;kann sein dass 1 und 0 based indexing
        ;;hier probleme macht ....
        ;;erstmal alles mit 2*i auf 2*i + 1 erhöht
        :at-least (fn [n cs ds es]
                    (for [i (range n)]
                      [#{(nth ds (inc i))
                         (negate (nth cs (+ 2 (* 2 i))))}
                       #{(nth es i)
                         (negate (nth cs (+ 2 (* 2 i))))}
                       #{(nth ds (inc i))
                         (nth es i)
                         (negate (nth cs (inc (* 2 i))))}]))
        :between (fn [n cs ds es]
                   (for [i (range n)]
                   [#{(negate (nth ds (inc i)))
                      (negate (nth es i))
                      (nth cs (+ 2 (* 2 i)))}
                    #{(negate (nth ds (inc i)))
                      (nth cs (inc (* 2 i)))}
                    #{(negate (nth es i))
                      (nth cs (inc (* 2 i)))}
                    #{(nth ds (inc i))
                      (negate (nth cs (+ 2 (* 2 i))))}
                    #{(nth es i)
                      (negate (nth cs (+ 2 (* 2 i))))}
                    #{(nth ds (inc i))
                      (nth es i)
                      (negate (nth cs (inc (* 2 i))))}]))})

     (defn split-even-odd [s]
       [(map (partial nth s) (range 1 (count s) 2))
        (map (partial nth s) (range 0 (count s) 2))])


     (defn h-merge-single [type a b]
       (let [cs (generate-unique-vars 2 "c")]
         [cs ((type base-case-clauses) a b cs)]))


     (defn h-merge [type as bs]
       (if (= (count as) 1)
         (do (assert (= (count bs) 1))
             (h-merge-single type (first as) (first bs)))
         (let [n (* 2 (count as))
               cs (generate-unique-vars n "c")
               [as-even as-odd] (split-even-odd as)
               [bs-even bs-odd] (split-even-odd bs)
               [ds s-odd] (h-merge type as-odd bs-odd)
               [es s-even] (h-merge type as-even bs-even)]
           [(concat [(first ds)] (rest (butlast cs)) [(last es)])
            (->> ((type recursive-case-clauses) (dec (count as)) cs ds es)
                 (apply concat s-odd s-even))])))


     (defn h-sort-length-2 [type [a b]]
       (h-merge type [a] [b]))

     (defn h-sort [type as]
       (if (= (count as) 2)
         (h-sort-length-2 type as)
         (let [n (quot (count as) 2)
               [ds s-d] (h-sort type (take n as))
               [d's s-d'] (h-sort type (drop n as))
               [cs s-m] (h-merge type ds d's)]
           [cs (concat s-d s-d' s-m)])))



     (defn s-merge-single [type a b]
       (let [cs (generate-unique-vars 2 "c")]
         [cs ((type base-case-clauses) a b cs)]))

     (defn s-merge
       "as and bs are sequences of vars of length n
        c is sequence of vars of length n+1
        returns set of clauses
        see http://www.cs.upc.edu/~erodri/webpage/papers/sat09-card.pdf"
       [type as bs]
       (if (= (count as) 1)
         (do (assert (= (count bs) 1))
             (s-merge-single type (first as) (first bs)))
         (let [cs (generate-unique-vars (inc (count as)) "c")
               [as-even as-odd] (split-even-odd as)
               [bs-even bs-odd] (split-even-odd bs)
               [ds s-odd] (s-merge type as-odd bs-odd)
               [es s-even] (s-merge type as-even bs-even)]
           [(into [] (cons (first ds) (rest cs)))
            (->> ((type recursive-case-clauses)
                  (quot (count as) 2)
                  cs ds es)
                 (apply concat s-odd s-even))])))


     (defn card
       "k-cardinality network Sequence A of length n = m*k with k power of
       two returns [c s] c sequence of length k and S set of clauses"
       [type as k]
       (if (= (count as) k)
         (h-sort type as)
         (let [[ds s-d] (card type (take k as) k)
               [d's s-d'] (card type (drop k as) k)
               [cs s-m] (s-merge type ds d's)]
           [(butlast cs)
            (concat s-d s-d' s-m)])))

     (defn next-power-of-2 [p]
       (if (== p 1) 2
           (->> (/ (Math/log p) (Math/log 2))
                double
                Math/ceil
                (Math/pow 2)
                int)))
     ;;TODO sind noch bugs drin zum beispiel
     ;;(get-assignment (at-least (map (comp gen-var #(str "a" %)) (range 5)) 3))
     ;; das funktioniert jetzt mit der Einführung der Zeile da unten
     ;; dafür aber das nicht mehr nur wenn die zeile wieder gelöscht wird, mist
     ;;(count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (at-least (map (comp gen-var #(str "a" %)) (range 5)) 2))))x
     (defn at-least-buggy [as p]
       (cond
         (== p 0) []
         (== p (count as)) (mapv (fn [s] #{s}) as)
         :else
         (let [n (count as)
               k (next-power-of-2 p)
               r (rem n k)
               additional-vars
               (if (= 0 r) [] (generate-unique-vars (- k r) "a" false))
               as (concat as additional-vars)
               [cs s] (card :at-least as k)]
           (concat s [#{(nth cs (dec p))}]))))



     ;;TODO auch bei at-most stimmt noch etwas wirklich nicht
     ;;(get-assignment (concat (at-most (map (comp gen-var #(str "a" %)) (range 5)) 3) (map (comp (fn [s] #{s}) gen-var #(str "a" %)) (range 4))))
     ;;das oben funktioniert nicht, weil dort der branch mit at-least genommen wird, at-most selbst scheint gut zu funktionieren
     (defn at-most [as p]
       (cond
         (== p 0) (mapv (comp (fn [s] #{s}) negate) as)
         (== p (count as)) []
         #_#_(> p (/ (count as) 2)) (at-least
                                 (map negate as)
                                 (- (count as) p))
         :else
         (let [n (count as)
               k (next-power-of-2 p)
               k (if (= k p) (* 2 k) k)
               r (rem n k)
               additional-vars
               (if (= 0 r) [] (generate-unique-vars (- k r) "a" false)) ;??
               as (concat as additional-vars)
               [cs s] (card :at-most as k)]
           (concat s [#{(negate (nth cs p))}]))))

     (defn at-least
       "cheating with at-most here :)"
       [as p]
       (at-most (map negate as) (- (count as) p)))

     (defn at-most-h-sort [as p]
      (let [[cs s] (h-sort :at-most as)]
         (concat s [#{(negate (nth cs p))}])))


     (defn in-between [as p q]
       (let [n (count as)
             k (next-power-of-2 q)
             k (if (= k q) (* 2 k) k)
             r (rem n k)
             additional-vars
             (if (= 0 r) [] (generate-unique-vars (- k r) "a" false)) ;??
             as (concat as additional-vars)
             [cs s] (card :between as k)]
         (concat s [#{(nth cs (dec p))} #{(negate (nth cs q))}])))


     (defn exactly-buggy [as k]
       (in-between as k k))

     (defn exactly [as k]
       (concat (at-most as k) (at-least as k)))



   #+end_src

   #+RESULTS:
* roundtripping interaction with sat solver                        :noexport:
  sat solver nehmen als eingabe eine Datei im dimacs format und
  geben dann die Belegung aus.  Um den folgenden code ordentlich
  auszuführen und testen zu können, wird ein roundtrip implementiert

** erzeugen einer dimacs Datei aus clauseln
   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     (defn encode-literal [name-map literal mkey]
       (if-let [numb (get name-map (:var literal))]
         [name-map (if (:negated? literal) (- numb) numb) mkey]
         (recur (assoc name-map (:var literal) (inc mkey)) literal (inc mkey))))

     (defn encode-clause [name-map clause mk]
       (reduce (fn [[name-map partial-clause mkey] next-literal]
                 (let [[name-map encoded-literal max-key]
                       (encode-literal name-map next-literal mkey)]
                   [name-map (conj partial-clause encoded-literal) max-key]))
               [name-map [] mk]
               clause))

     ;;neues Format für Clauses:
     ;;clauses = clause +
     ;;clause = #{literal+} | [ #{literal+} weigth]

     (defn encode
       "encodes the clauses to dimacs format"
       ([clauses] (encode clauses true))
       ([clauses max-sat?]
        (let [[name-map encoded mkey weights]
              (reduce (fn [[name-map partial-clauses mkey ws] next-clause]
                        (let [soft-clause? (and max-sat? (sequential? next-clause))
                              [name-map encoded-clause max-key]
                              (encode-clause
                               name-map (if soft-clause?
                                          (first next-clause)
                                          next-clause) mkey)]
                          [name-map (conj partial-clauses encoded-clause) max-key
                           (conj ws (if soft-clause? (second next-clause) :hard))]))
                      [{} [] 0 []]
                      clauses)
              hard-weigth (max 1 (reduce + (remove #{:hard} weights)))]
          [name-map
           (apply str "c generated " (if max-sat? "wcnf" "cnf") " file\n"
                  "p " (if max-sat? "wcnf " "cnf ")
                  (count (keys name-map)) " "
                  (count encoded)
                  (if max-sat? (str " " hard-weigth) "") "\n"
                  (interpose
                   "\n"
                   (map #(apply str
                                (if max-sat?
                                  (str (if (= :hard %2) hard-weigth %2) " ")
                                  "")
                                (concat (interpose " " %1) " 0"))
                        encoded weights)))])))

     (defn parse-output [output name-map]
       (let [lines (.split output "\n")
             inv-map (->> (for [[a b] name-map] [b a]) (into {}))]
         (reduce
          (fn [var-map line]
            (if (.startsWith line "v ")
              (merge var-map
                     (->> (rest (.split line " "))
                          (map #(Integer/parseInt %))
                          (remove #{0}) ;;s4j includes a 0 in the end
                          (map (fn [v]
                                 (let [inv (inv-map (Math/abs v))]
                                   [inv (pos? v)])))
                          (into {})))
              (do (when (.startsWith line "o ")
                    (prn "best weight so far " line))
                  var-map))) nil lines)))

     (def last-name-map (atom nil))

     (defn get-assignment
       ([clauses] (get-assignment clauses "resources/cnf1" true))
       ([clauses filename] (get-assignment clauses filename true))
       ([clauses filename maxsat?]
        (let [[name-map encoded] (encode clauses maxsat?)
              _ (spit filename encoded)
              _ (reset! last-name-map name-map)
              _ (spit "resources/last-name-map.edn" (pr-str name-map))
              _ (prn "starting solver")
              output
              (time (:out
               (sh/sh "sh" "-c"
                      (if maxsat?
                      "timeout -s SIGTERM 300 ./resources/open-wbo_static resources/cnf1 > resources/output"
                        "timeout -s SIGTERM 1800 java -jar resources/sat4j-sat.jar resources/cnf1 > resources/output"))))
              output (slurp "resources/output")]
          (spit "resources/current-output" output)
          (println "sat solver finished")
          (parse-output output name-map))))



     (deftest test-get-assignment
       (is (= '{x true, y false}
              (get-assignment [#{(gen-var 'x)} #{(gen-var 'y false)}])))
       (is (nil? (get-assignment [#{(gen-var 'x false)} #{ (gen-var 'x)}])))
       (is (= (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (at-most (map (comp gen-var #(str "a" %)) (range 10)) 1) (at-least (map (comp gen-var #(str "a" %)) (range 10)) 1))))) 1))
       (is (= 0 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (at-most (map (comp gen-var #(str "a" %)) (range 9)) 4) (map (comp (fn [s] #{s}) gen-var #(str "a" %)) (range 5))))))))
       (is (= 15 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (exactly (map (comp gen-var #(str "a" %)) (range 20)) 15))))))
       (is (= 1 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (exactly (map (comp gen-var #(str "a" %)) (range 20)) 1) (map (comp (fn [s] #{s}) negate gen-var #(str "a" %)) (range 19))))))))
       (is (= 0 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (exactly (map (comp gen-var #(str "a" %)) (range 20)) 1) (map (comp (fn [s] #{s}) negate gen-var #(str "a" %)) (range 20))))))))
       (is (= 0 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (exactly (map (comp gen-var #(str "a" %)) (range 20)) 1) (map (comp (fn [s] #{s}) gen-var #(str "a" %)) (range 2))))))))
       (is (= 1 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (exactly (map (comp gen-var #(str "a" %)) (range 20)) 1) (map (comp (fn [s] #{s}) gen-var #(str "a" %)) (range 1))))))))
       (is (= 0 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (at-most (map (comp gen-var #(str "a" %)) (range 9)) 4) (map (comp (fn [s] #{s}) gen-var #(str "a" %)) (range 5))))))))
       (is (= 4 (count (filter (fn [[n v]] (and (<= (count (str n)) 4) v)) (get-assignment (concat (at-most (map (comp gen-var #(str "a" %)) (range 9)) 4) (map (comp (fn [s] #{s}) gen-var #(str "a" %)) (range 4)))))))))


     (test-get-assignment)


     (defn complete-entities  [entities assignment]
       (reduce-kv (fn [entities k v]
                    (cond
                      (and v (.startsWith (name k) "starts-at-hour"))
                      (let [[_ event-id day hour] (.split (name k) "_")
                            [event-name occ] (.split event-id ":")]
                        (assoc-in entities [:events
                                            (keyword event-name)
                                            :times
                                            (Integer/parseInt occ)]
                                            [(Integer/parseInt day) (Integer/parseInt hour)]))
                      (and v (.startsWith (name k) "occurs-at-room"))
                      (let [[_ event-id building-name room-name] (.split (name k) "_")
                            [event-name occ] (.split event-id ":")]
                        (assoc-in entities [:events
                                            (keyword event-name)
                                            :rooms
                                            (Integer/parseInt occ)]
                                  #{[(keyword building-name) (keyword room-name)]}))
                      :else entities)) entities assignment))

     (defn fill-timetable [events-for-class num-days hours-per-day]
       (let [timetable (vec (repeat hours-per-day
                                    (vec (repeat num-days ""))))]
         (reduce (fn [timetable [event-name details]]
                   (update-in timetable (vec (reverse (:time details)))
                                  #(str (if (seq %) (str "Doppelbelegung " (apply str (take 20 %))) "")
                                        event-name  " in " (first (:rooms details)) " " details))) timetable events-for-class)))

     (defn get-solution [entities]
       (complete-entities entities (parse-output (slurp "resources/output") @last-name-map)))

     (defn show-timetable [title timetable]
       (-> (frame :title title
                  :content (scrollable (table :model [:columns
                                                      (mapv (fn [d] {:key (keyword (str "day-" d))
                                                                     :text (str d)})
                                                            (range (count (first timetable))))
                                                      :rows timetable])))
           pack! show!))

     (defmulti show-timetable-for (fn [type name entities] type))

     (defmethod show-timetable-for :class [_ class-name {:keys [events num-days hours-per-day]}]
       (let [events-for-class
             (for [[event {classes :classes :as details}] (events-to-schedule events)
                   :when (classes class-name)]
               [event details])]
         (show-timetable (str "timetable-for-class " class-name)
                         (fill-timetable events-for-class num-days hours-per-day))))

     (defmethod show-timetable-for :teacher [_ teacher-name {:keys [events num-days hours-per-day]}]
       (let [events-for-teacher
             (for [[event {teachers :teachers :as details}] (events-to-schedule events)
                   :when (teachers teacher-name)]
               [event details])]
         (show-timetable (str "timetable-for-teacher " teacher-name)
                         (fill-timetable events-for-teacher num-days hours-per-day))))

     (defmethod show-timetable-for :room [_ room-name {:keys [events num-days hours-per-day]}]
       (let [events-for-room
             (for [[event {rooms :rooms :as details}] (events-to-schedule events)
                   :when (rooms room-name)]
               [event details])]
         (show-timetable (str "timetable-for-room " room-name)
                         (fill-timetable events-for-room num-days hours-per-day))))


   #+end_src
* Representation von aussagenlogischen Formeln in konjunktiver Normalform :noexport:
  :PROPERTIES:
  :ORDERED:  t
  :END:
  #+begin_src clojure :ns timetabling.logic :tangle src/timetabling/logic.clj
    (ns timetabling.logic
      (:require [clojure.set :as set]))
  #+end_src

  Ein Literal in der Aussagenlogik ist entweder eine Variable $a$
  oder eine Negation einer Variable $\neg a$

  In clojure it will be represented by a map with a :var and
  a :negated? key
  #+begin_src clojure :ns timetabling.logic :tangle src/timetabling/logic.clj
    (defn gen-var
      ([x] (gen-var x true))
      ([x b]
       {:negated? (not b)
        :var x}))
  #+end_src
  negate turns a true literal to a false one and the other way round
  #+begin_src clojure :ns timetabling.logic :tangle src/timetabling/logic.clj
    (defn negate [v]
      (update-in v [:negated?] not))
  #+end_src
  Eine Disjunktion von literalen, zum Beispiel $a \vee b \vee \ldots \vee c$
  wird als set von literalen dargestellt, zum Beispiel
  #+BEGIN_SRC clojure
  #{(gen-var 'a) (gen-var 'b) (gen-var 'c)}
  #+END_SRC
  $\neg a \vee b$ disjunktion
  #+begin_src clojure :ns timetabling.logic :tangle src/timetabling/logic.clj
    (defn implies
      "a is a variable and b is either a single variable
       or a set of variables"
      [a b]
      (set/union #{(negate a)} (if (set? b) b #{b})))
  #+end_src
  Schließlich werden Konjunktionen von Ausdrücken $a \wedge b \wedge \ldots \wedge c$
  durch einen Vektor, oder eine Sequenz dargestellt
  #+BEGIN_SRC clojure
  [(gen-var 'a) (gen-var 'b) (gen-var 'c)]
  #+END_SRC
  Der Ausdruck
  \[(b \vee \neg c) \wedge (\neg a \vee c)\]
  wird so dargestellt wurch
  #+BEGIN_SRC clojure
  [#{(gen-var b) (gen-var c false)} #{(negate (gen-var a)) (gen-var c)}]
  #+END_SRC
* Teilproblem: Zuweisung von Lehrern und Räumen schon bekannt
  Als Erstes wird das leichtere Problem betrachtet, bei dem die
  Zuweisung von Events zu Räumen vorgegeben ist und nur noch die
  Zeiten der Veranstaltungen gesucht werden müssen. Dieses Problem
  bietet sich an, um grundlegend festzustellen, ob das
  Stundenplanproblem  auf Problemgrößen, die von einer dreizügigen
  Grundschule stammen, mit SAT solvern in realistischer Zeit gelöst
  werden kann.

  Andererseits ist dieses Teilproblem für die Stundenplanung an einer
  Grundschule nicht ganz unrealistisch, da
  - eine Grundschulklasse wahrscheinlich die meiste Zeit vom
    Klassenlehrer unterrichtet wird
  - meistens die Fächer in dem Klassenraum unterrichtet werden,
    sowie in wohlbekannten Räumen für spezielle Fächer,
    beispielsweise Sporthalle für Sport.


** Erstellung eines zulässigen Stundenplans
   In den folgenden Abschnitten wird beschrieben, wie in dieser
   Situation die Bedingungen an einen zulässigen Stundenplan in
   aussagenlogische Klauseln übersetzt werden können.

   Dafür werden erstmal einige Bezeichnungen eingeführt.

*** Einführung von Variablen
    Im Weiteren werden folgende Bezeichnungen benutzt:
    - $\operatorname{Events}$ sei die Menge der zu verplanenden
      Events, also Vorkommen von Veranstaltungen.
      $\operatorname{Teachers}$, $\operatorname{Classes}$,
      $\operatorname{Rooms}$, $\operatorname{Buildings}$ seien die
      Mengen von Lehrern, Klassen, Räumen und Gebäuden.
    - Die Operatoren $\operatorname{classes}(e)$,
      $\operatorname{teachers}(e)$ geben für ein Event $e$ die Menge
      aller teilnehmenden Klassen, bzw. Lehrer, zurück.
      $\operatorname{resources}(e) = \operatorname{classes}(e) \cup
      \operatorname{teachers}(e)$.
    - Der Operator $\operatorname{rooms}(e)$ gibt die Menge von
      Räumen, in der das Event stattfindet, zurück. Es ist erlaubt,
      dass eine Veranstaltung in mehreren Räumen stattfindet, die sich
      allerdings alle in dem selben Gebäude befinden müssen.
    - Der Operator $\operatorname{building}(e)$ gibt das Gebäude für
      das Event $e$ zurück. Der Operator $\operatorname{building}(r)$
      gibt das Gebäude zurück, in dem sich der Raum $r$ befindet.
    - Der Operator $\operatorname{duration}(e)$ beschreibt die Dauer
      des Events $e$.
    - $\operatorname{Times}$, $\operatorname{Days}$ seien die Mengen an
      Tagen und Stunden.
    - Der Operator $\operatorname{day}(ts)$ gibt den Tag zurück, der
      zu der Stunde $ts$ gehört, während der Operator
      $\operatorname{hours}(d)$ die Menge aller Stunden des Tages $d$
      zurückgibt. Die erste Stunde eines Tages $d$ gibt der Operator
      $\operatorname{first-hour}(d)$ zurück.
    - Ein Raum, ein Lehrer und eine Klasse können für bestimmte Zeiten
      nicht erreichbar, bzw. nicht zu verplanen sein. Der Operator
      $\operatorname{times-not-available}(r)$ gibt die Menge dieser
      Stunden für $r$ zurück.
    - Schließlich gibt der Operator $\operatorname{events-for}(r)$ die
      Menge an Events zurück, an denen $r$ teilnimmt. $r$ kann dabei
      eine Klasse, ein Lehrer, oder ein Raum sein.

    Zur Übersetzung der Bedingungen in Aussagenlogik werden folgende
    logischen Variablen benutzt:
    - $\text{occurs-at-hour}_{e,h}$ ist \texttt{true} genau dann, wenn ein Event $e$ auf die Stunde $h$ gelegt wurde.
      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (defn occurs-at-hour
          "event is the name of the event, hour is an integer"
          [event [day hour]]
          (gen-var (symbol (str "occurs-at-hour_" (name event) "_" day "_" hour))))
      #+end_src
    - $\text{occurs-at-day}_{e,h}$ ist \texttt{true} genau dann, wenn ein
      Event $e$ auf eine Stunden am Tag $d$ gelegt wurde.
      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn occurs-at-day
          "event is the name of the event, day is an integer"
          [event day]
          (gen-var (symbol (str "occurs-at-day_" (name event) "_" day))))
      #+end_src
    - $\text{occurs-at-room}_{e,h}$ ist \texttt{true} genau dann, wenn Event
      $e$ auf Raum $r$ in gelegt wurde.
      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (defn occurs-at-room
          "event is the name of the event, day is an integer"
          [event [building room]]
          (gen-var (symbol (str "occurs-at-room_" (name event) "_" (name building) "_" (name room)))))
      #+end_src
    - $\text{teached-at}_{c,h}$ ist \texttt{true} genau dann, wenn die Klasse $c$ zur Zeit $h$ unterrichtet wird
      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (defn teached-at [class [day hour]]
          (gen-var (symbol (str "teached-at_" (name class) "_" day "_" hour))))
      #+end_src
    - $\text{teaches-at}_{t,h}$ ist \texttt{true} genau dann, wenn der Lehrer $t$ zur Zeit $h$ unterrichtet.
      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (defn teaches-at [teacher [day hour]]
          (gen-var (symbol (str "teaches-at_" (name teacher) "_" day "_" hour))))
      #+end_src

   Damit die eingeführten Variablen keine widersprüchlichen
   Belegungen zulassen, müssen die logischen Beziehungen zwischen
   ihnen explizit in Aussagenlogik erfasst werden.

*** Beziehungen zwischen den Variablen
    \label{oah-oad}
   Wenn ein Event zu einer Stunde stattfindet, so findet es auch an
   dem dazugehörigen Tag statt. Ebenso findet ein Event, das an einem
   Tag stattfindet, auch an mindestens einer Stunde dieses Tages
   statt. Dies lässt sich durch

   \[\forall e \in \operatorname{Events}, \forall d \in \operatorname{Days} \hspace{3mm} \operatorname{occurs-at-day}_{e,d} \Leftrightarrow \bigvee_{h \in \operatorname{hours}(d)} \operatorname{occurs-at-hour}_{e,h}\]

   in Prädikatenlogik erster Stufe formulieren.

   Um diese Formel in konjunktive Normalform der Aussagenlogik zu
   bringen, werden folgende Umformungsregeln benutzt:

   1. $a \Leftrightarrow b = (a \Rightarrow b) \wedge (b \Rightarrow a)$
   2. $a \Rightarrow b = \neg a \vee b$

   Aus der Hinrichtung ( $\Rightarrow$ ) ergibt sich für jedes zu verplanende Event $e$ und jeden Tag $d$ eine Klausel
   \[ \neg \operatorname{occurs-at-day}_{e,d} \vee  \bigvee_{h \in \operatorname{hours}(d)} \operatorname{occurs-at-hour}_{e,h} \text{ .
}\]
   Aus der Rückrichtung ($\Leftarrow$) ergibt sich mit den De-Morganschen Regeln
   \begin{align}
   &\bigvee_{h \in \operatorname{hours}(d)} \operatorname{occurs-at-hour}_{e,h} \Rightarrow \operatorname{occurs-at-day}_{e,d}\\
   =& \neg \left (\bigvee_{h \in \operatorname{hours}(d)} \operatorname{occurs-at-hour}_{e,h} \right ) \vee \operatorname{occurs-at-day}_{e,d} \\
   =& \left ( \bigwedge_{h \in \operatorname{hours}(d)} \neg \operatorname{occurs-at-hour}_{e,h} \right ) \vee \operatorname{occurs-at-day}_{e,d} \\
   =& \bigwedge_{h \in \operatorname{hours}(d)} ( \neg \operatorname{occurs-at-hour}_{e,h} \vee \operatorname{occurs-at-day}_{e,d}) \text{ .}
   \end{align}
   Insgesamt wird so für jedes Event $e$ und Zeit $h$ die Klausel
   \[ \neg \operatorname{occurs-at-hour}_{e,h} \vee \operatorname {occurs-at-day}_{e,\operatorname{day}(h)} \]
   erzeugt, um die Rückrichtung darzustellen.
   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     (defn occurs-at-day-occurs-at-hour-relations
       [{:keys [events num-days hours-per-day]}]
       (concat
        (for [[event _] (events-to-schedule events)
              day (range 0 num-days)
              hour (range 0 hours-per-day)]
          (implies (occurs-at-hour event [day hour])
                   (occurs-at-day event day)))
        (for [[event _] events
              day (range 0 num-days)
              :let [occurs-at-hours
                    (for [hour (range 0 hours-per-day)]
                      (occurs-at-hour event [day hour]))]]
          (implies (occurs-at-day event day) (into #{} occurs-at-hours)))))

   #+end_src

   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     (deftest day-hour-relations
       (is (= '(#{{:negated? true, :var occurs-at-hour_a:0_0_0}
        {:negated? false, :var occurs-at-day_a:0_0}}
      #{{:negated? false, :var occurs-at-day_a:0_0}
        {:negated? true, :var occurs-at-hour_a:0_0_1}}
      #{{:negated? false, :var occurs-at-day_a:0_1}
        {:negated? true, :var occurs-at-hour_a:0_1_0}}
      #{{:negated? true, :var occurs-at-hour_a:0_1_1}
        {:negated? false, :var occurs-at-day_a:0_1}}
      #{{:negated? false, :var occurs-at-hour_a_0_0}
        {:negated? true, :var occurs-at-day_a_0}
        {:negated? false, :var occurs-at-hour_a_0_1}}
      #{{:negated? false, :var occurs-at-hour_a_1_0}
        {:negated? false, :var occurs-at-hour_a_1_1}
        {:negated? true, :var occurs-at-day_a_1}})
               (occurs-at-day-occurs-at-hour-relations {:events {:a {:durations [1]}} :num-days 2 :hours-per-day 2}))))

     (day-hour-relations)
   #+end_src

   #+RESULTS:


   Wenn ein Event zu einer Stunde stattfindet, dann werden auch alle
   Klassen, die an dem Event teilnehmen, zu dieser Zeit
   unterrichtet. Anderstherum, wenn eine Klasse zu einer Zeit
   unterrichtet wird, dann gibt es ein Event, welches für diese
   Klasse stattfindet, dass zu dieser Zeit stattfindet.

   \[\forall c \in \operatorname{Classes}, \forall h \in
   \operatorname{Hours} \hspace{3mm} \operatorname{teached-at}_{c,h} \Leftrightarrow
   \bigvee_{e \in \operatorname{Events} \text{,} c \in
   \operatorname{classes}(e)} \operatorname{occurs-at-hour}_{e,h} \]

   Durch analoge Umformungen ergeben sich die folgenden Klauseln: Für
   jede Klasse $c$ und Zeit $h$

   \[\neg \operatorname{teached-at}_{c,h} \vee \bigvee_{e \in \operatorname{Events} \text{,} c \in \operatorname{classes}(e)} \operatorname{occurs-at-hour}_{e,h} \text{ ,}\]
   sowie für jedes Event $e$, Klasse $c \in \mathit{classes}(e)$ sowie Zeit $h$
   \[\neg \operatorname{occurs-at-hour}_{e,h} \vee \operatorname{teached-at}_{c,h} \text{ .}\]

     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       (defn occurs-at-hour-teached-at-relations
         [{:keys [events num-days hours-per-day classes]}]
         (concat
          (for [[event {classes-for-event :classes}] (events-to-schedule events)
                day (range num-days)
                hour (range hours-per-day)
                class classes-for-event]
            (implies (occurs-at-hour event [day hour])
                     (teached-at class [day hour])))
          (for [[class _] classes
                :let [events-for-class (for [[event {cl :classes}]
                                             (events-to-schedule events)
                                             :when (cl class)]
                                         event)]
                day (range num-days)
                hour (range hours-per-day)]
            (implies (teached-at class [day hour])
                     (into #{} (map #(occurs-at-hour % [day hour])
                                    events-for-class))))))
     #+end_src

     #+RESULTS:
     : #'timetabling.core/occurs-at-hour-teached-at-relations

     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       (deftest test-occurs-at-teached-at-relations
         (is (= '(#{{:negated? true, :var occurs-at-hour_b:0_0_0} {:negated? false, :var teached-at_class1_0_0}} #{{:negated? false, :var teached-at_class1_0_1} {:negated? true, :var occurs-at-hour_b:0_0_1}} #{{:negated? true, :var occurs-at-hour_b:0_1_0} {:negated? false, :var teached-at_class1_1_0}} #{{:negated? false, :var teached-at_class1_1_1} {:negated? true, :var occurs-at-hour_b:0_1_1}} #{{:negated? true, :var occurs-at-hour_a:0_0_0} {:negated? false, :var teached-at_class1_0_0}} #{{:negated? true, :var occurs-at-hour_a:0_0_0} {:negated? false, :var teached-at_class2_0_0}} #{{:negated? true, :var occurs-at-hour_a:0_0_1} {:negated? false, :var teached-at_class1_0_1}} #{{:negated? false, :var teached-at_class2_0_1} {:negated? true, :var occurs-at-hour_a:0_0_1}} #{{:negated? false, :var teached-at_class1_1_0} {:negated? true, :var ccurs-at-hour_a:0_1_0}} #{{:negated? true, :var occurs-at-hour_a:0_1_0} {:negated? false, :var teached-at_class2_1_0}} #{{:negated? false, :var teached-at_class1_1_1} {:negated? true, :var occurs-at-hour_a:0_1_1}} #{{:negated? true, :var occurs-at-hour_a:0_1_1} {:negated? false, :var teached-at_class2_1_1}} #{{:negated? false, :var occurs-at-hour_a:0_0_0} {:negated? false, :var occurs-at-hour_b:0_0_0} {:negated? true, :var teached-at_class1_0_0}} #{{:negated? true, :var teached-at_class1_0_1} {:negated? false, :var occurs-at-hour_a:0_0_1} {:negated? false, :var occurs-at-hour_b:0_0_1}} #{{:negated? true, :var teached-at_class1_1_0} {:negated? false, :var occurs-at-hour_a:0_1_0} {:negated? false, :var occurs-at-hour_b:0_1_0}} #{{:negated? false, :var occurs-at-hour_b:0_1_1} {:negated? false, :var occurs-at-hour_a:0_1_1} {:negated? true, :var teached-at_class1_1_1}} #{{:negated? false, :var occurs-at-hour_a:0_0_0} {:negated? true, :var teached-at_class2_0_0}} #{{:negated? false, :var occurs-at-hour_a:0_0_1} {:negated? true, :var teached-at_class2_0_1}} #{{:negated? false, :var occurs-at-hour_a:0_1_0} {:negated? true, :var teached-at_class2_1_0}} #{{:negated? true, :var teached-at_class2_1_1} {:negated? false, :var occurs-at-hour_a:0_1_1}})
                (occurs-at-hour-teached-at-relations {:events {:a {:classes #{:class1 :class2} :durations [1]} :b {:classes #{:class1} :durations [1]}} :num-days 2 :hours-per-day 2 :classes #{:class1 :class2}}))))


       (test-occurs-at-teached-at-relations)
     #+end_src

     #+RESULTS:


   Die $\operatorname{teaches-at}$ Beziehung ist für Lehrer das Analogon der $\operatorname{teached-at}$ Beziehung für Klassen.
   Die logische Äquivalenz ist

   \[\forall t \in \operatorname{Teachers} \forall h \in
   \operatorname{Times} \hspace{3mm}\operatorname{teaches-at}_{t,h}
   \Leftrightarrow \bigvee_{e \in \operatorname{Events} \text{,} t
   \in \operatorname{teachers}(e)}
   \operatorname{occurs-at-hour}_{e,h}\text{ .}\]

   Die Klauseln in konjunktiver Normalform sind entsprechend:
   Für jeden Lehrer $t$ und Zeit $h$
   \[\neg \operatorname{teaches-at}_{t,h} \vee \bigvee_{e \in \operatorname{Events} \text{,} t \in \operatorname{teachers}(e)} \operatorname{occurs-at-hour}_{e,h} \text{ ,}\]
   sowie für jedes Event $e$, Lehrer $t \in \operatorname{teachers}(e)$ sowie Zeit $h$
   \[\neg \operatorname{occurs-at-hour}_{e,h} \vee \operatorname{teaches-at}_{t,h} \text{ .}\]


     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       (defn occurs-at-hour-teaches-at-relations
         [{:keys [events num-days hours-per-day teachers]}]
         (concat
          (for [[event {teachers-for-event :teachers}]
                (events-to-schedule events)
                day (range num-days)
                hour (range hours-per-day)
                teacher teachers-for-event]
            (implies (occurs-at-hour event [day hour])
                     (teaches-at teacher [day hour])))
          (for [[teacher _] teachers
                :let [events-for-teacher (for [[event {tchs :teachers}]
                                               (events-to-schedule events)
                                               :when (tchs teacher)]
                                           event)]
                day (range num-days)
                hour (range hours-per-day)]
            (implies (teaches-at teacher [day hour])
                     (into #{} (map #(occurs-at-hour % [day hour])
                                    events-for-teacher))))))
     #+end_src

   Mit den bisher definierten Variablen und ihren Beziehungen
   zueinander können die Anforderungen an einen zulässigen Stundenplan
   ausgedrückt werden. Dies wird in den nächsten Abschnitten im Detail
   beschrieben.

*** Verhindern von Doppelbelegungen
    Sobald ein Event auf eine bestimmte Zeit gelegt wurde, dürfen
    alle daran beteiligten Resourcen zu dieser Zeit nicht anderweitig
    belegt werden.

    Explizit muss für jede Klasse, Raum, Lehrer die Menge der
    Veranstaltungen gefunden werden, in denen sie vorkommen. Von
    diesen Veranstaltungen darf zu jeder Zeit /höchstens 1/
    stattfinden. Dies führt auf eine $\operatorname{at-most}$ Kardinalitätsbedingung:

    \[\forall r \in \operatorname{Teachers} \cup \operatorname{Classes} \cup \operatorname{Rooms} \hspace{3mm} \operatorname{at-most}(\{\operatorname{occurs-at-hour}_{e,h} | e \in \operatorname{events-for}(r)\}, 1)\]

    Die Kodierung dieser Kardinalitätsbedingungen in aussagenlogische
    Klauseln konjunktiver Normalform erfolgt nach dem in [[cite:card]]
    beschriebenen Algorithmus, welcher in [[ref:card]] beschrieben wird.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn class-clash-constraints
        [{:keys [classes events num-days hours-per-day]}]
        (for [[class _] classes
              :let [events-for-class
                    (for [[e d] (events-to-schedule events)
                          :when ((:classes d) class)]
                      e)]
              :when (seq events-for-class)
              day (range num-days)
              hour (range hours-per-day)
              clause (at-most (map #(occurs-at-hour % [day hour])
                                    events-for-class) 1)]
          clause))

      (defn teacher-clash-constraints
        [{:keys [teachers events num-days hours-per-day]}]
        (for [[teacher _] teachers
              :let [events-for-teacher
                    (for [[e d] (events-to-schedule events)
                          :when ((:teachers d) teacher)]
                      e)]
              :when (seq events-for-teacher)
              day (range num-days)
              hour (range hours-per-day)
              clause (at-most (map #(occurs-at-hour % [day hour])
                                    events-for-teacher) 1)]
          clause))


      (defn room-clash-constraints
        [{:keys [buildings events num-days hours-per-day]}]
        (for [[b rooms] buildings
              [r _] rooms
              :let [events-for-room
                    (for [[e d] (events-to-schedule events)
                          :when ((:rooms d) [b r])]
                      e)]
              :when (seq events-for-room)
              day (range num-days)
              hour (range hours-per-day)
              clause (at-most (map #(occurs-at-hour % [day hour])
                                    events-for-room) 1)]
          clause))
    #+end_src

*** Vorbelegte Räume und Zeiten
    Für alle bekannten Zuordnungen von Räumen und Zeiten werden die
    entsprechenden Variablen gesetzt. Die Bedingung für vorbelegte
    Räume lautet:

    Für jedes Event $e$ mit vorbelegten Räumen und jedem Raum $r \in rooms(e)$ wird eine Klausel
    \[\operatorname{occurs-in-room}_{e,r}\]

    gefordert. Ist auch die Zeit eines Eventes bekannt, dann wird
    die entsprechende occurs-at-hour variable gesetzt:

    Für jedes Event $e$ mit bekannter Zeit $h \in \operatorname{time}(e)$ wird die Klausel

    \[\operatorname{occurs-at-hour}_{e,h}\]

    gefordert.
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn predetermined-room-constraints
        [{:keys [events num-days hours-per-day]}]
        (for [[event {rooms :rooms}] (events-to-schedule events)
              room rooms
              :when room]
          #{(occurs-at-room event room)}))

      (defn predetermined-times-constraints
        [{:keys [events num-days hours-per-day]}]
        (for [[event {time :time}] (events-to-schedule events)
              :when time]
          #{(occurs-at-hour event time)}))
    #+end_src

*** Beachten von Zeitbeschränkungen
    Ein Lehrer, eine Klasse oder ein Raum kann an bestimmten
    Zeitpunkten nicht erreichbar sein. Dann darf kein Event, an dem
    die jeweilige Resource teilnimmt, zu dieser Zeit stattfinden.

    \begin{align*}
    &\forall r \in \operatorname{Rooms}  \cup \operatorname{Teachers} \cup \operatorname{Classes}, \forall t \in \operatorname{times-not-available}(r) \\ &\bigwedge_{e \in \{e | e \in \operatorname{Events}, r \in \operatorname{resources}(e)\}} \neg \operatorname{occurs-at-hour}_{e,t}
    \end{align*}

    Hier wurde ausgenutzt, dass die Belegung von Lehrern, Klassen und
    Räumen eines Events schon bekannt ist. In dem später betrachteten
    Problem, bei dem die Räume der Veranstaltungen selbst verplant
    werden, muss diese Bedingung für Räume angepasst werden.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn rooms-not-available-constraints
        [{:keys [events buildings num-days hours-per-day]}]
        (for [[building rooms] buildings
              [room details] rooms
              :let [times-not-available (:times-not-available details)
                    events-for-room
                    (for [[e d] (events-to-schedule events)
                          :when ((:rooms d) [building room])]
                      e)]
              event events-for-room
              time times-not-available]
          #{(negate (occurs-at-hour event time))}))
    #+end_src

*** Events mit längerer Dauer
    Im Gegensatz zu [[cite:ttpsat]], gibt es in der Grundschule Events,
    die sich über mehr als einen Zeitslot erstrecken. um Events mit
    längerer Dauer bearbeiten zu können, wird eine neue Variablensorte
    eingeführt. Für jedes Event $e$ und Zeit $h$ gibt es eine Variable
    \[\operatorname{starts-at-hour}_{e,h} \text{ ,}\] welche für ein
    Event mit Dauer 1 äquivalent zu occurs-at-hour ist.
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
    (defn starts-at-hour
    [event [day hour]]
    (gen-var (symbol (str "starts-at-hour_" (name event) "_" day "_" hour))))
    #+end_src

    Allgemein:
    \begin{align*}
    \forall e \in \operatorname{Events}, \forall h \in \operatorname{Hours} \\
    \operatorname{starts-at-hour}_{e,h} \Leftrightarrow
    \bigvee_{h' \in \{h \ldots h + \operatorname{duration}(e) - 1\}}
    \operatorname{occurs-at-hour}_{e,h'}
    \end{align*}

    Durch Aufspalten von $\Leftrightarrow$, der Elimination von
    $\Rightarrow$ und mit den de Morganschen Regeln ergeben sich die
    folgenden Klauseln:

    Für alle nachfolgenden Stunden $h' \in  \{h \ldots h + \operatorname{duration}(e) - 1\}$

    \[\neg \operatorname{starts-at-hour}_{e,h} \vee \operatorname{occurs-at-hour}_{e,h'} \text{ ,}\]

    sowie für alle vorherigen Stunden h'

    \[\neg \operatorname{occurs-at-hour}_{e,h} \vee \bigvee_{h' \in \{h \ldots h + \operatorname{duration}(e) - 1\}}
     \operatorname{starts-at-hour}_{e,h'} \text{ .}\]

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn starts-at-hour-occurs-at-hour-relations
        [{:keys [events num-days hours-per-day]}]
        (concat
         (for [[event {:keys [duration]}] (events-to-schedule events)
               day (range 0 num-days)
               hour (range 0 hours-per-day)
               [nd nh] (cons [day hour]
                             (next-times-at-day [day hour] hours-per-day (dec duration)))]
           (implies (starts-at-hour event [day hour])
                    (occurs-at-hour event [nd nh])))
         (for [[event {:keys [duration]}] (events-to-schedule events)
               day (range 0 num-days)
               hour (range 0 hours-per-day)
               :let [starting-times
                     (cons [day hour]
                           (previous-times-at-day [day hour] (dec duration)))]]
           (implies (occurs-at-hour event [day hour])
                    (into #{} (map #(starts-at-hour event %) starting-times))))))
                #+end_src

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
                    (deftest test-starts-at-hour-occurs-at-hour-relations
                      (is (= '(#{{:negated? false, :var occurs-at-hour_bla:0_0_0}
                       {:negated? true, :var starts-at-hour_bla:0_0_0}}
                     #{{:negated? false, :var occurs-at-hour_bla:0_0_1}
                       {:negated? true, :var starts-at-hour_bla:0_0_0}}
                     #{{:negated? false, :var occurs-at-hour_bla:0_0_1}
                       {:negated? true, :var starts-at-hour_bla:0_0_1}}
                     #{{:negated? false, :var occurs-at-hour_bla:0_0_2}
                       {:negated? true, :var starts-at-hour_bla:0_0_1}}
                     #{{:negated? false, :var occurs-at-hour_bla:0_0_2}
                       {:negated? true, :var starts-at-hour_bla:0_0_2}}
                     #{{:negated? true, :var occurs-at-hour_bla:0_0_0}
                       {:negated? false, :var starts-at-hour_bla:0_0_0}}
                     #{{:negated? true, :var occurs-at-hour_bla:0_0_1}
                       {:negated? false, :var starts-at-hour_bla:0_0_1}
                       {:negated? false, :var starts-at-hour_bla:0_0_0}}
                     #{{:negated? true, :var occurs-at-hour_bla:0_0_2}
                       {:negated? false, :var starts-at-hour_bla:0_0_1}
                       {:negated? false, :var starts-at-hour_bla:0_0_2}})
                             (starts-at-hour-occurs-at-hour-relations {:num-days 1 :hours-per-day 3 :events {:bla (create-event :durations [2] :number-of-times 1)}}))))

                    (test-starts-at-hour-occurs-at-hour-relations)
                #+end_src

*** Unmögliche Zeiten für längere Veranstaltungen
    Eine Konsequenz aus dem Vorhandensein von Events, die mehr als
    einen Zeitslot dauern ist, dass diese nicht zu nahe am Ende eines
    Tages stattfinden dürfen.  Formal gilt für ein Event $e$ mit
    $\operatorname{duration}(e) = d$, dass es an jedem Tag $t$ nicht
    zu den Stunden $h_{t,\text{max} - d + 2}\ldots h_{t,\text{max}}$
    stattfinden darf.

    \[\forall e \in \operatorname{Events}, \forall t \in \operatorname{Days} \hspace{3mm} \neg \left ( \bigvee_{h =
h_{t,\text{max} - d + 2}\ldots h_{t,\text{max}}} \operatorname{starts-at-hour}_{e,h}  \right )\]

   In konjunktiver Normalform ergibt sich die Klausel

   \[\neg \operatorname{starts-at-hour}_{e,h}\]

   für alle Events $e$ und entsprechenden Stunden $h$.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn illegal-starting-times-constraints
        [{:keys [events num-days hours-per-day]}]
        (for [[event {:keys [duration]}] (events-to-schedule events)
              hour (range (dec hours-per-day) (- hours-per-day duration) -1)
              day (range num-days)]
          #{(negate (starts-at-hour event [day hour]))}))
    #+end_src

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (deftest test-illegal-starting-times-constraints
        (is (= '(#{{:negated? true, :var starts-at-hour_bla:0_0_2}}
       #{{:negated? true, :var starts-at-hour_bla:0_1_2}})
                (illegal-starting-times-constraints {:num-days 2 :hours-per-day 3 :events {:bla (create-event :durations [2] :number-of-times 1)}}))))


      (test-illegal-starting-times-constraints)
    #+end_src

*** Beachten von Wechselzeiten zwischen Gebäuden

    Die betrachtete Grundschule hat mehrere Gebäude, die nicht am
    gleichen Platz stehen, weshalb Wegzeiten zwischen ihnen eingeplant
    werden müssen. Bei einem zulässigen Stundenplan darf es für
    keinen Lehrer und für keine Klasse vorkommen, dass sie
    zu einem Zeitpunkt $t_1$ in Gebäude 1 sind und danach in Gebäude 2
    verplant sind, aber nicht genügend Zeit haben, um zwischen den
    Gebäuden zu wechseln. Anders ausgedrückt, darf es kein Paar von
    verschiedenen Events $(e_1,e_2) \in \operatorname{Events} \times
    \operatorname{Events}$ $e_1 \neq e_2$ geben, die sich einen Lehrer oder
    eine Klasse teilen

    \[\operatorname{resources}(e_1) \cap \operatorname{resources}(e_{2}) \neq \emptyset \text{ ,}\]

    und in unterschiedlichen Gebäuden $b_1$ und $b_2$ stattfinden und
    ihre Zeiten an einem Tag zu dicht hintereinander liegen, genauer
    $|h_1 - h_2| < \operatorname{distance}(b_1,b_2)$ mit
    $\operatorname{day}(h_1) = \operatorname{day}(h_2)$. Der Operator
    $\operatorname{times-changing}(e_1,e_2,h_1)$ bezeichne diese Zeiten.

    Im Folgenden sei der Operator
    $\operatorname{events-with-common-resource}(e)$ eingeführt, der die
    Menge der Events zurückgibt, welche sich nach obiger Bedingung
    einen Lehrer oder Klasse mit $e$ teilen.

    In Logik kann man diese Bedingung wie folgt ausdrücken. Wenn ein
    Event $e_1$ zur Zeit $h$ in Gebäude $b_{1}$ stattfindet, dann
    folgt, dass kein anderes Event $e_2$ mit gemeinsamen Lehrer oder
    Klasse, welches in Gebäude $b_2$ stattfindet, zur Stunde $h + 1,
    h + 2, \ldots h + \operatorname{distance}(b_1,b_2)$ stattfinden darf:

    \begin{align*}
    &\forall e_1 \in \operatorname{Events},  \forall h \in \operatorname{Hours} \hspace{3mm}
      \operatorname{occurs-at-hour_{e_1,h}}  \Rightarrow \\ &\bigwedge_{e_2 \in \operatorname{events-with-common-resource}(e_1), h_2 \in \operatorname{times-changing}(e_1,e_2,h)} \neg \operatorname{occurs-at-hour}_{e_2,h_2}\
    \end{align*}

    Als Klauseln erhält man explizit:
    \begin{align*}
        &\neg \operatorname{occurs-at-hour}_{e1,h} \vee \neg \operatorname{occurs-at-hour}_{e_2,h_2} \\
    \end{align*}

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn distances-constraints
        [{:keys [events buildings num-days hours-per-day distances]}]
        (for [[event {:keys [classes teachers rooms]}] (events-to-schedule events)
              :let [building (ffirst rooms)]
              [e dist] (for [[e {rs :rooms cls :classes tchs :teachers}]
                             (events-to-schedule events)
                             :let [b (ffirst rs)
                                   distance (get distances [building b] 0)]
                             :when (and (not= b building) (not= event e)
                                        (> distance 0)
                                        (or (some classes cls) (some teachers tchs)))]
                         [e distance])
              day (range num-days)
              hour (range hours-per-day)
              [nd nh] (next-times-at-day [day hour] hours-per-day dist)]
          (implies (occurs-at-hour event [day hour])
                   (negate (occurs-at-hour e [nd nh])))))


    #+end_src

*** Jedes zu belegende Event muss belegt werden
    Schließlich muss noch für einen zulässigen Stundenplan
    sichergestellt werden, dass jedes zu verplanende Event auch
    verplant wird, und dass es nicht doppelt verplant wird. Auch diese
    Bedingung führt auf eine Kardinalitätsbedingung, dass /exakt/ eine
    der gegebenen Variablen \texttt{true} sein muss.

    \[\forall e \in \operatorname{Events} \hspace{3mm} \operatorname{exactly}(\{\operatorname{starts-at-hour}_{e,h} | h \in \operatorname{Hours}\},1)\]
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj

      (defn everything-scheduled-constraints
        [{:keys [events num-days hours-per-day]}]
        (for [[event _] (events-to-schedule events)
              clause (exactly (for [day (range num-days)
                             hour (range hours-per-day)]
                         (starts-at-hour event [day hour])) 1)]
          clause))
    #+end_src

*** Sammeln aller Constraint funktions                             :noexport:
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def constraint-functions
        [#'occurs-at-day-occurs-at-hour-relations
         #'occurs-at-hour-teached-at-relations
         #'class-clash-constraints
         #'room-clash-constraints
         #'teacher-clash-constraints
         #'everything-scheduled-constraints
         #'predetermined-room-constraints
         #'predetermined-times-constraints
         #'rooms-not-available-constraints
         #'distances-constraints
         #'starts-at-hour-occurs-at-hour-relations
         #'illegal-starting-times-constraints
         #'occurs-at-hour-teaches-at-relations])

      (defn run-constraints
        ([entities] (run-constraints entities constraint-functions))
        ([entities constraint-functions]
         (reduce (fn [clauses cf]
                   (println "creating constraints from " cf)
                   (concat clauses (doall (cf entities))))
                 [] constraint-functions)))

      (def last-assignment (atom nil))

      (defn solve-problem
        ([entities] (solve-problem
                     entities {:constraint-functions constraint-functions :maxsat? true}))
        ([entities {:keys [constraint-functions maxsat?]
                    :or {constraint-functions constraint-functions
                          maxsat? true}}]
         (let [_ (prn "encoding constraints")
               constraints (doall (run-constraints entities constraint-functions))
               _ (prn "get-assignment")
               ass (get-assignment constraints "resources/cnf1" maxsat?)
               _ (reset! last-assignment ass)]
           (when ass
               (complete-entities entities ass)))))
    #+end_src

    #+RESULTS:
    : #'timetabling.core/constraint-functions#'timetabling.core/run-constraints
*** Ergebnisse
    Um zu sehen, dass der Algorithmus funktioniert, werden hier zuerst
    einige sehr einfache Probleme vorgestellt, bei denen man die
    korrekte Lösunug sehen kann.

    Beim ersten Beispiel gibt es zwei Klassen, zwei Lehrer, zwei
    Gebäude mit je einem Raum und pro Klasse zwei zu verplanende Events, Mathe und Deutsch.

    - Mathe für Klasse 1 findet im Raum 1 des Gebäudes 1 statt, dauert eine
      Stunde und wird vom Lehrer 1 unterrichtet.

    - Deutsch für Klasse 1 findet im Raum 1 des Gebäudes 2 statt, dauert
      eine Stunde und wird vom Lehrer 1 unterrichtet.

    - Mathe für Klasse 2 findet im Raum 1 des Gebäudes 2 statt, dauert eine
      Stunde und wird vom Lehrer 2 unterrichtet.

    - Deutsch für Klasse 2 findet im Raum 1 des Gebäudes 1 statt, dauert
      eine Stunde und wird vom Lehrer 2 unterrichtet.

    - Es gibt einen Tag mit 2 Stunden.
      Zwischen den beiden Gebäuden braucht es keine Reisezeit.
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def basic-example-problem
        {
         :classes {:class-1 {}
                   :class-2 {}}
         :teachers {:teacher-1 {}
                    :teacher-2 {}}
         :buildings {:building-1 {:room-1 {}
                                  :room-2 {}}
                     :building-2 {:room-1 {}
                                  :room-2 {}}}
         :num-days 1
         :hours-per-day 2
         :distances {}
         :events
         {:class-1-math
          (create-event :classes :class-1 :rooms #{[:building-1 :room-1]}
                        :teachers #{:teacher-1} :number-of-times 1)
          :class-1-deutsch
          (create-event :classes :class-1 :rooms #{[:building-2 :room-1]}
                        :teachers #{:teacher-1} :number-of-times 1)
          :class-2-math
          (create-event :classes :class-2 :rooms #{[:building-2 :room-1]}
                        :teachers #{:teacher-2} :number-of-times 1)
          :class-2-deutsch
          (create-event :classes :class-2 :rooms #{[:building-1 :room-1]}
                        :teachers #{:teacher-2} :number-of-times 1)}
         })
    #+end_src

    Nach obigen Beschreibungen wird für dieses Problem eine Formel in
    konjunktiver Normalform mit 136 Klauseln erzeugt, diese Formel dem
    SAT-Solver SAT4J übergeben, und aus der Variablenzuweisung der
    Stundenplan generiert.

    In dem erzeugten Stundenplan wird Deutsch für Klasse 1 und
    Deutsch für Klasse 2 jeweils auf die erste, und Mathe für Klasse 1
    und Mathe für Klasse 2 auf die zweite Stunde gesetzt, wie in
    Abbildungen [[ref:img:first]] und [[ref:img:second]] dargestellt. Dabei
    sind die Tage startend mit 0 nummeriert und in den Spalten
    dargestellt, während in jeder Zeile ein Zeitslot dargestellt ist.
    Abbildung [[ref:img:first]] wird beispielsweise erläutert:

    An der Form des Stundenplanes wird klar, dass es einen Tag mit
    zwei Zeitslots gibt. Beide sind dabei verplant. Im ersten Slot
    findet der Deutschunterricht für Klasse 2 statt, was durch den
    Namen $\operatorname{:class-2-deutsch}$ angezeigt wird. Der
    Namenszusatz $\operatorname{:0}$ wird zur eindeutigen Bezeichnung
    der einzelnen zu verplanenden Vorkommen der Veranstaltung benutzt.
    In diesem Beispiel ist das unnötig, da die Klasse 2 hier nur
    einmal pro Woche in Deutsch unterrichtet wird. Der Rest der
    Tabellenzelle ist mit detaillierteren Informationen für dieses
    Event gefüllt, welche aber zum Verständniss des Stundenplans
    ignoriert werden können.

    Ebenso ist in dem zweiten Slot des ersten Tages der
    Mathematikunterricht für Klasse 2 geplant.

    #+ATTR_LaTeX: :width 200px
    #+CAPTION: Stundenplan für Klasse 1
    #+LABEL: img:first
    [[file:images/basic-problem-class-1.png][file:~/programming/timetabling/images/basic-problem-class-1.png]]

    #+ATTR_LaTeX: :width 200px
    #+CAPTION: Stundenplan für Klasse 2
    #+LABEL: img:second
    [[file:images/basic-problem-class-2.png][file:~/programming/timetabling/images/basic-problem-class-2.png]]



    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (deftest test-basic-example
        (is (= {:classes {:class-1 {}, :class-2 {}}, :teachers {:teacher-1 {}, :teacher-2 {}}, :buildings {:building-1 {:room-1 {}, :room-2 {}}, :building-2 {:room-1 {}, :room-2 {}}}, :num-days 1, :hours-per-day 2, :distances {}, :events {:class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]}], :teachers [#{:teacher-1}], :durations [1], :allowed-rooms :all, :times [[0 1]]}, :class-1-deutsch {:classes #{:class-1}, :rooms [#{[:building-2 :room-1]}], :teachers [#{:teacher-1}], :durations [1], :allowed-rooms :all, :times [[0 0]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-2 :room-1]}], :teachers [#{:teacher-2}], :durations [1], :allowed-rooms :all, :times [[0 1]]}, :class-2-deutsch {:classes #{:class-2}, :rooms [#{[:building-1 :room-1]}], :teachers [#{:teacher-2}], :durations [1], :allowed-rooms :all, :times [[0 0]]}}}
               (solve-problem basic-example-problem {:maxsat? false}))))


      (test-basic-example)
    #+end_src

    Als Modifikation wird eine Stunde Reisezeit zwischen Gebäude 1 und
    Gebäude 2 gefordert. Dies führt dazu, dass nicht mehr genügend
    Zeit bleibt, um zwischen den Gebäuden zu reisen, und tatsächlich
    liefert der SAT-Solver bei dem Problem den Nachweis der
    Unerfüllbarkeit.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def failing-example
        (assoc basic-example-problem
               :distances {[:building-1 :building-2] 1
                           [:building-2 :building-1] 1}))
    #+end_src

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
    (deftest test-failing-example-fails
    (is (nil? (solve-problem failing-example))))

    (test-failing-example-fails)
    #+end_src


    Wird daraufhin die Anzahl der Stunden pro Tag auf 3 erhöht, wird
    das Problem wieder lösbar und in dem erzeugten Stundenplan ist, wie
    beim unmodifizierten Beispiel jeweils Deutsch in der ersten
    Stunde verplant, Mathe aber erst in der dritten Stunde, sodass
    beide Klassen und beide Lehrer genug Zeit haben, um von Gebäude 1
    zu Gebäude 2 zu gelangen.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def enough-time-example
        (assoc failing-example
               :hours-per-day 3))
    #+end_src

    #+CAPTION: Stundenplan für Klasse 1 mit drei Stunden pro Tag
    #+ATTR_LaTeX: :width 200px
    [[file:images/basic-problem-enough-time-class-1.png][file:~/programming/timetabling/images/basic-problem-enough-time-class-1.png]]

    #+CAPTION: Stundenplan für Klasse 2 mit drei Stunden pro Tag
    #+ATTR_LaTeX: :width 200px
    [[file:images/basic-problem-enough-time-class-2.png][file:~/programming/timetabling/images/basic-problem-enough-time-class-2.png]]


    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (deftest test-enough-time
        (is (= {:classes {:class-1 {}, :class-2 {}}, :teachers {:teacher-1 {}, :teacher-2 {}}, :buildings {:building-1 {:room-1 {}, :room-2 {}}, :building-2 {:room-1 {}, :room-2 {}}}, :num-days 1, :hours-per-day 3, :distances {[:building-2 :building-1] 1, [:building-1 :building-2] 1}, :events {:class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]}], :teachers [#{:teacher-1}], :durations [1], :allowed-rooms :all, :times [[0 0]]}, :class-1-deutsch {:classes #{:class-1}, :rooms [#{[:building-2 :room-1]}], :teachers [#{:teacher-1}], :durations [1], :allowed-rooms :all, :times [[0 2]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-2 :room-1]}], :teachers [#{:teacher-2}], :durations [1], :allowed-rooms :all, :times [[0 0]]}, :class-2-deutsch {:classes #{:class-2}, :rooms [#{[:building-1 :room-1]}], :teachers [#{:teacher-2}], :durations [1], :allowed-rooms :all, :times [[0 2]]}}} (solve-problem enough-time-example))))

      (test-enough-time)
    #+end_src

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (deftest test-basic-example
        (is (= {:classes {:class-1 {}, :class-2 {}}, :teachers {:teacher-1 {}, :teacher-2 {}}, :buildings {:building-1 {:room-1 {}, :room-2 {}}, :building-2 {:room-1 {}, :room-2 {}}}, :num-days 1, :hours-per-day 2, :distances {}, :events {:class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]}], :teachers [#{:teacher-1}], :durations [1], :allowed-rooms :all, :times [[0 1]]}, :class-1-deutsch {:classes #{:class-1}, :rooms [#{[:building-2 :room-1]}], :teachers [#{:teacher-1}], :durations [1], :allowed-rooms :all, :times [[0 0]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-2 :room-1]}], :teachers [#{:teacher-2}], :durations [1], :allowed-rooms :all, :times [[0 1]]}, :class-2-deutsch {:classes #{:class-2}, :rooms [#{[:building-1 :room-1]}], :teachers [#{:teacher-2}], :durations [1], :allowed-rooms :all, :times [[0 0]]}}}
               (solve-problem basic-example-problem {:maxsat? false}))))


      (test-basic-example)
   #+end_src
*** Untersuchung der Skalierbarkeit
    \label{skalierbarkeit-simple}
    Die Untersuchung der Skalierbarkeit des Programmes zur
    automatischen Stundenplanerzeugung stellt sich als schwierig
    heraus. Man kann nicht getrennt voneinander die Anzahlen der
    Lehrer, Klassen, Events und Zeitslots ändern und
    gleichzeitig den Stundenplan erfüllbar halten:
    - Wenn man zu viele Events für die Anzahl von Lehrern und
      Klassen hat, dann haben diese zu wenig Stunden in der Woche zur
      Verfügung, um alle ihnen zugeordneten Events zu
      besuchen.
    - Das Gleiche passiert, wenn man die Anzahl von Klassen erhöht,
      ohne die Anzahl von Lehrern anzupassen.
    - Die Anzahl von Räumen ist bei dem hier vorgestellten Teilproblem
      unerheblich, außer es stehen zu wenige für die Anzahl der Events
      zur Verfügung.

    Außerdem ist es problematisch, die Schwierigkeit eines Problems an
    seinen Eingabgrößen zu messen. Es gibt Probleme mit vergleichbarer
    Anzahl an Klassen, Lehrern, Räumen und Veranstaltungen, wobei
    einige schwerer für den Solver zu lösen sind als andere. Dies kann
    zum Beispiel daran liegen, dass es bei einem Problem sehr viele
    mögliche Lösungen gibt, und der Solver relativ schnell auf eine
    davon stößt, es bei einem anderen aber nur eine einzige zulässige
    Zuweisung der Events zu Zeiten gibt.

    Um trotz dieser Schwierigkeiten eine Aussage über die
    Skalierbarkeit des hier vorgestellten Ansatzes zu treffen, wird
    ein skalierbares Beispielproblem konstruiert. Dieses
    Beispielproblem wird durch die Anzahl der Klassen skaliert. jede
    Klasse hat dabei genauso viele Veranstaltungen zugeordnet, wie es
    Zeitslots gibt und für Jede Klasse wird ein neues Gebäude angelegt
    mit dem Klassenraum für die Klasse, welcher ebenfalls vollständig
    ausgebucht wird. Für $n$ Klassen enthält das skalierbare
    Beispielproblem somit:
    - 5 Tage mit je 7 Stunden
    - $n$ Gebäude mit je einem Raum.
    - $n$ Klassenlehrer.
    - $n*5*7$ Veranstaltungen, wobei für Klasse $j$ die 35
      Veranstaltungen beim Klassenlehrer $j$ und in dem Raum im
      $j$-ten Gebäude stattfinden.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn create-scalable-problem [num-hours num-days num-classes]
        (let [num-slots (* num-days num-hours)]
          {:classes (reduce #(assoc %1 (keyword (str "class-" %2))
                                    {:class-teacher (keyword (str "teacher-" %2))
                                     :class-room [(keyword (str "building-" %2)) :room-1]})
                            {} (range num-classes))
           :teachers (reduce #(assoc %1 (keyword (str "teacher-" %2)) {}) {} (range num-classes))
           :distances {}
           :num-days num-days
           :hours-per-day num-hours
           :buildings (reduce #(assoc %1 (keyword (str "building-" %2)) {:room-1 {}})
                              {} (range num-classes))
           :events (reduce #(assoc %1 (keyword (str "ef-" %2))
                                   (create-event :classes (keyword (str "class-" %2))
                                                 :rooms #{[(keyword (str "building-" %2)) :room-1]}
                                                 :teachers #{(keyword (str "teacher-" %2))}
                                                 :number-of-times num-slots))
                           {} (range num-classes))}))
    #+end_src

    Dadurch, dass die so erzeugten Beispielprobleme für die geforderte
    Anzahl von Klassen die maximal mögliche Anzahl von
    Veranstaltungen haben und dadurch für einen zulässsigen
    Stundenplan die vorkommenden Resourcen völlig ausgebucht sein
    müssen, sind diese Beispielprobleme schwer für den Solver zu
    lösen. Wenn das Beispielproblem mit 10 Klassen beispielsweise in
    kurzer Zeit gelöst werden kann, dann liegt die Vermutung nahe,
    dass bei einem zufälligen Problem, welches auch 10 Klassen
    aufweist und lösbar ist, ebenfalls in kurzer Zeit eine Lösung
    gefunden werden kann.

    Zum Vergleich: Bei dem vorgestellten größeren Beispielproblem mit
    12 Klassen wurden 313578 Klauseln in 3.6 Sekunden erzeugt und der
    Solver hat 2.6 Sekunden gebraucht.

    #+CAPTION: Anzahl erzeugter Klauseln und Laufzeit des Solvers bei unterschiedlicher Klassenzahl
    #+NAME: tab:skal-simple
    | Klassen | Klauseln | Laufzeit (s) des Solvers |
    |---------+----------+--------------------------|
    |      10 |   924050 |                     12,3 |
    |      20 |  1848100 |                     41,7 |
    |      30 |  2772150 |                     69,5 |
    |      40 |  3696200 |                    131,1 |
    |      50 |  4620250 |                    191,4 |
    |      60 |  5544300 |                    351,6 |
    |      70 |  6468350 |                    434,3 |
    |      80 |  7392400 |                    583,2 |
    |      90 |  8316450 |                    732,7 |
    |     100 |  9240500 |                    904,3 |


    In Tabelle [[ref:tab:skal-simple]] ist das Verhalten des Algorithmus
    für die oben beschriebenen Beispielprobleme mit 10 bis 100 Klassen
    dargestellt. Die Anzahl an erzeugten Klauseln ist dabei strikt
    linear abhängig von der Anzahl der Klassen. Während der Solver zur
    Lösung des auf 10 Klassen skalierten Problems noch 12 Sekunden
    gebraucht hat, sind es für 70 Klassen schon über sieben Minuten
    und über 15 Minuten für 100 Klassen.

    Diese Untersuchung zeigt, dass dieses Teilproblem auch noch für
    Schulen gut lösbar ist, die um einiges größer als die Grundschule
    Oslebshausen sind.

    Wenn man für jede Klasse 36 Events vergibt, wird der Stundenplan
    nicht mehr lösbar, da es in der Woche nur 25 Zeitslots gibt.
    Solche Situationen werden allerdings nicht durch den verwendete
    Solver erkannt. Bei der Eingabegröße von 10 Klassen je 36
    Veranstaltungen pro Klasse, hat der Solver nach einer Stunde
    Laufzeit noch keine Aussage über die Lösbarkeit der Formel treffen
    können.

    Eine zukünftige Erweiterung des Programmes könnte vor der
    Erzeugung der Klauseln verschiedene Erfüllbarkeitstests
    durchführen. Diese Tests könnten unter anderem Folgendes beinhalten:
    - Eine Klasse oder ein Lehrer hat zu viele Events zugewiesen.
    - Es gibt zu viele Events für zur Verfügung stehende Räume.
    - Ein Lehrer, Klasse oder Raum hat zu viele Zeiten, in denen er
      nicht erreichbar ist, um alle Veranstaltungen abhalten zu können


** Erstellung eines optimalen Stundenplans
   Durch Formulierung der Bedingungen an einen möglichst optimalen Stundenplan
   und anschließender Übertragung in das Weighted Partial MAX-SAT Problem kann
   man die erstellten Stundenpläne optimieren.

   Die hier beschriebenen Optimalitätsbedingungen umfassen zwei Heuristiken:
   - Minimierung von Lücken zwischen Veranstaltungen für Klassen sowie Lehrer
   - Minimierung von Wechsel zwischen Gebäuden für Klassen sowie Lehrer

   Die in der Einleitung erwähnte Forderung nach einem Maß für die
   Rhytmisierung des Unterrichtes, wird dabei in dieser Arbeit nicht
   behandelt. Für spätere Anwendungen wären genauere Bedingungen mit
   den Kontaktpersonen der Grundschule abzuklären.

*** Minimierung der Lücken zwischen Veranstaltungen für Klassen
    Bei einem optimalen Stundenplan soll eine Klasse in ihrem
    Wochenstundenplan möglichst wenig /Lücken/ am Tag haben. In
    [[cite:ttpsat]] wird die Bedingung wie folgt umgesetzt:

    Eine Lücke erkennt man daran, dass eine Klasse zum Zeitpunkt $h_1$
    an einem Tag unterrichtet wird, am Zeitpunkt $h_1 + 1$ aber nicht
    mehr. Von daher kann man die Bedingung fordern, dass für eine
    Stunde, an der eine Klasse unterrichtet wird, sie auch an der
    Stunde davor und der Stunde danach an diesem Tag unterrichtet
    wird. Ist das nicht erfüllt, gibt es eine Lücke im Stundenplan der
    Klasse. Mit diesen Klauseln ist ein Gewicht von 1 verbunden.

    Für jede Klasse und die erste Stunde $h$ eines Tages wird die weiche Klausel gesetzt:

    \[\operatorname{teached-at}_{c,h} \Rightarrow
    \operatorname{teached-at}_{c,h+1} = \neg
    \operatorname{teaced-at}_{c,h} \vee
    \operatorname{teached-at}_{c,h+1}\]

    Falls $h$ die letzte Stunde eines Tages ist, wird die weiche Klausel gefordert:

    \[\neg \operatorname{teached-at}_{c,h} \vee \operatorname{teached-at}_{c,h-1}\]

    Und falls $h$ weder die letzte noch die erste Stunde eines Tages
    ist, werden beide Bedingungen gefordert:

    \[\neg \operatorname{teached-at}_{c,h} \vee \operatorname{teached-at}_{c,h+1}\]
    \[\neg \operatorname{teached-at}_{c,h} \vee \operatorname{teached-at}_{c,h-1}\]

    Allerdings hat diese Umsetzung noch Probleme:
    1. Es wird auch eine Lücke gezählt, wenn für eine Klasse die
       letzte Stunde am Tag nicht die letzte Stunde des Tages ist oder
       die erste Stunde für die Klasse nicht die erste Stunde des
       Tages ist.
    2. Es wird nur die Anzahl der Lücken gezählt, größere Lücken
       werden nicht schlimmer bewertet als kleinere Lücken.

    Diese Probleme können behoben werden, indem man nicht mehr
    fordert, dass wenn eine Klasse zu einer Stunde unterrichtet wird,
    sie auch an angrenzenden Stunden des Tages unterrichtet wird,
    sondern stattdessen fordert, dass sie, wenn sie zu einer
    Stunde unterrichtet wird und danach $x$ Stunden nicht unterrichtet
    wird, sie auch die $x+1$-te Stunde danach nicht unterrichtet wird. Ist
    diese Bedingung verletzt, liegt eine Lücke der Größe $x$ vor und
    kann entsprechend gewichtet werden.

    Um eine Lücke der Größe $x$ zu vermeiden, muss also folgender
    Ausdruck in aussagenlogische konjunktive Normalform gebracht
    werden:

    \begin{align*}
    \forall c \in \operatorname{Classes}, d\in \operatorname{Days}, h \in \{h: h\in \operatorname{hours}(d) \wedge h + x < \max(\operatorname{hours}(d))\} \\
    \left(\operatorname{teached-at_{c,h}} \wedge \bigwedge
    _{h' \in \{h,\ldots,h + x\}} \neg \operatorname{teached-at_{c,h'}} \right) \Rightarrow \neg \operatorname{teached-at_{c,h + x + 1}}
    \end{align*}

    Durch Auflösen der Implikation und Reinziehen der Negation ergeben
    sich für jede Klasse $c$, jeden Tag $d$, und jede Stunde $h$ des
    Tages, die mehr als $x$ Stunden von der letzten des Tages entfernt
    ist, die Klausel

    \[\neg \operatorname{teached-at}_{c,h} \vee \bigvee_{h' \in \{h,\ldots,h + x\}} \operatorname{teached-at}_{c,h'} \vee \neg \operatorname{teached-at}_{c,h+x+1} \text{ .}\]

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn minimize-gaps-for-classes-constraints
        ([entities] (minimize-gaps-for-classes-constraints entities 1))
        ([{:keys [classes num-days hours-per-day]} cost]
         (for [[class _] classes
               day (range num-days)
               x (range 1 (dec hours-per-day))
               hour (range (- hours-per-day x 1))]
           [(set/union #{(negate (teached-at class [day hour]))
                         (negate (teached-at class [day (+ hour x 1)]))}
                       (into #{} (map #(teached-at class [day %])
                                      (range (inc hour) (+ hour x 1))))) (* x cost)])))
    #+end_src


    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn old-minimize-gaps-for-classes-constraints
        ([entities] (minimize-gaps-for-classes-constraints entities 1))
        ([{:keys [classes num-days hours-per-day]} cost]
         (for [[class _] classes
               day (range num-days)
               hour (range hours-per-day)
               clause (cond
                        (= 0 hour)
                        [(implies (teached-at class [day 0])
                                  (teached-at class [day 1]))]
                        (= (dec hours-per-day) hour)
                        [(implies (teached-at class [day hour])
                                  (teached-at class [day (dec hour)]))]
                        :else
                        [(implies (teached-at class [day hour])
                                  (teached-at class [day (dec hour)]))
                         (implies (teached-at class [day hour])
                                  (teached-at class [day (inc hour)]))])]
           [clause cost])))
    #+end_src
*** Minimierung der Lücken zwischen Veranstaltungen für Lehrer
    Auch Lehrer sollen möglichst wenige Lücken zwischen ihren
    Veranstaltungen haben. Das Vorgehen dazu ist direkt analog zum
    Vorgehen beim Vermeiden von Lücken zwischen Veranstaltungen für
    Klassen, wobei die Variabel teached-at durch teaches-at ersetzt wird.
    Für jeden Lehrer und die erste Stunde $h$ eines Tages wird die weiche Klausel gesetzt:

    \[\neg \operatorname{teaches-at}_{t,h} \vee \operatorname{teached-at}_{t,h+1}\]

    Falls $h$ die letzte Stunde eines Tages ist wird die weiche Klausel gefordert:

    \[\neg \operatorname{teaches-at}_{t,h} \vee \operatorname{teaches-at}_{t,h-1}\]

    Falls $h$ weder die letzte noch die erste Stunde eines Tages ist,
    werden beide Bedingungen gefordert:

    \[\neg \operatorname{teaches-at}_{t,h} \vee \operatorname{teaches-at}_{t,h+1}\]
    \[\neg \operatorname{teached-at}_{c,h} \vee \operatorname{teached-at}_{c,h-1}\]

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn minimize-gaps-for-teachers-constraints
        ([entities] (minimize-gaps-for-teachers-constraints entities 1))
        ([{:keys [teachers num-days hours-per-day]} cost]
         (for [[teacher _] teachers
               day (range num-days)
               x (range 1 (dec hours-per-day))
               hour (range (- hours-per-day x 1))]
           [(set/union #{(negate (teaches-at teacher [day hour]))
                         (negate (teaches-at teacher [day (+ hour x 1)]))}
                       (into #{} (map #(teaches-at teacher [day %])
                                      (range (inc hour) (+ hour x 1))))) (* x cost)])))
    #+end_src


    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn old-minimize-gaps-for-teachers-constraints
        ([entities] (minimize-gaps-for-teachers-constraints entities 1))
        ([{:keys [teachers num-days hours-per-day]} cost]
         (for [[teacher _] teachers
               day (range num-days)
               hour (range hours-per-day)
               clause (cond
                        (= 0 hour)
                        [(implies (teaches-at teacher [day 0])
                                  (teaches-at teacher [day 1]))]
                        (= (dec hours-per-day) hour)
                        [(implies (teaches-at teacher [day hour])
                                  (teaches-at teacher [day (dec hour)]))]
                        :else
                        [(implies (teaches-at teacher [day hour])
                                  (teaches-at teacher [day (dec hour)]))
                         (implies (teaches-at teacher [day hour])
                                  (teaches-at teacher [day (inc hour)]))])]
           [clause cost])))
    #+end_src
*** Minimierung der Wechsel zwischen Gebäuden für Klassen
    \label{obiger-abschnitt}
    Für einen optimalen Stundenplan sollte eine Klasse möglichst wenig
    zwischen Gebäuden wechseln, wenn zwischen ihnen eine Reisezeit anfällt.

    Die Anforderungen an die Minimierung der Gebäudewechsel sind:
    - Ein Gebäudewechsel soll mehr gewichtet werden als eine bloße Lücke
      zwischen Veranstaltungen.
    - Je größer die Entfernung zwischen den Gebäuden ist, desto stärker
      soll ein Wechsel gewichtet werden.

    Man könnte sich vorstellen, den Wechsel zwischen Gebäuden ähnlich
    zu Klauseln in konjunktiver Normalform zu übersetzen, wie die
    Minimierung der Lücken zwischen Veranstaltungen,
    indem man nach Einführung einer Variable
    $\operatorname{teached-in-building}_{c,h}$, eine weiche Klausel

    \[\operatorname{teached-in-building}_{c,h} \Rightarrow \operatorname{teached-in-building}_{c,h+1}\]

    mit einer gewissen Gewichtung fordert.

    Dies hat aber folgende Probleme:
    - Es wird nicht unterschieden, zwischen welchen Gebäuden
      gewechselt wird. Wenn zwischen zwei Gebäuden gewechselt wird,
      die weiter entfernt sind, dann sollte die Nichterfüllung der
      Klausel stärker gewichtet werden.
    - Es kommt nicht mit den Lücken zwischen den Veranstaltungen klar,
      welche schon durch die Distances-constraints bei jedem
      zulässigen Stundenplan vorhanden sind.

    Wenn man nur eine Lücke zwischen zwei Gebäuden hätte, dann könnte
    man darauf schauen, dass eine Klasse zu einer Stunde nicht
    unterrichtet wird, aber vorher und nachher in unterschiedlichen
    Gebäuden unterrichtet wird. Dies kommt allerdings nicht mit einem
    Gebäudewechsel klar, der länger als eine Zeitstunde benötigt.

    Im Folgenden wird eine Kodierung beschrieben, die beiden oben
    genannten Anforderungen gerecht wird und auch mit längeren Lücken
    umgehen kann.

    Die Schlüsselidee ist, die Beziehung
    $\operatorname{class-in-building}_{c,h,b}$ einzuführen, die
    besagt, dass die Klasse $c$ zur Stunde $h$ /zuletzt/ im Gebäude
    $b$ unterrichtet wurde. Bei einer größeren Lücke kaskadiert
    diese Variable die Lücke entlang und der oben erwähnte check

    \[\operatorname{class-in-building}_{c,h,b} \Rightarrow
    \operatorname{class-in-building}_{c,h+1,b}\]

    schlägt an.

    Die zweite Anforderung, dass längere Lücken mehr gewichtet werden, als
    kürzere, lässt sich dadurch sicherstellen, dass man die Wechsel
    zwischen jedem Paar von Gebäuden einzeln betrachtet.

    Für jede Klasse $k$, Zeit $h$ und Gebäude $b$ wird die logische Variable

    \[\operatorname{class-in-building}_{k,h,b}\]

    eingeführt.
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn class-in-building [class [day hour] building]
        (gen-var (symbol (str "class-in-building_" (name class) "_" day "_"
                              hour "_" (name building)))))
    #+end_src

    Bevor diese Variable genutzt werden kann, muss ihre oben
    beschriebene Beziehung als Klauseln festgehalten werden.

    Die Beziehungen von class-in-building kann man rekursiv bestimmen:

    $\operatorname{class-in-building}_{c,b,h}$ ist \texttt{true} genau dann, wenn
    1. Ein Event $e$, an dem die Klasse teilnimmt und das in Gebäude $b$ zur
       Zeit $h$ stattfindet:

       \[\operatorname{occurs-at-hour}_{e,h} \hspace{5mm} c \in
       \operatorname{classes}(e)\text{, } b =
       \operatorname{building}(e) \text{, }\]
       
       oder
    2. $h$ nicht die erste Stunde eines Tages ist, die Klasse $c$
       nicht zur Zeit $h$ unterrichtet wird, und sie die Stunde davor
       im Gebäude $b$ zuletzt unterrichtet wurde:

      \[ \neg \operatorname{teached-at}_{c,h} \wedge
       \operatorname{class-in-building}_{c,h-1,b} \hspace{5mm} h \neq
       \operatorname{first-hour}(\operatorname{day}(h))\]

    Es ergibt sich die folgende logische Äquivalenz:
    \begin{align}
    \label{eq:cib}
    &\forall c \in \operatorname{Classes}, h \in \operatorname{Times}, b \in \operatorname{Buildings} \nonumber \\
    &\operatorname{class-in-building}_{c,h,b} \Leftrightarrow \\
    &\bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
 &\vee h \neq \operatorname{first-hour}(\operatorname{day}(h)) \wedge \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b}
    \end{align}

    Diese Äquivalenz muss nun in die konjunktive Normalform der Aussagenlogik
    umgewandelt werden. Diese Umwandlung wird hier im Detail beschrieben:

    Zuerst wird [[ref:eq:cib]] in die einzelnen Implikationen aufgespalten
    \begin{align}
    \label{eq:hinr}
        & \operatorname{class-in-building}_{c,h,b} \Rightarrow
    \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
 &\vee h \neq \operatorname{first-hour}(\operatorname{day}(h)) \wedge \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b} \text{ , }
    \end{align}

    sowie
   \begin{align}
    \label{eq:rueckr}
         &
    \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
 &\vee h \neq \operatorname{first-hour}(\operatorname{day}(h)) \wedge \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b} \\
 & \Rightarrow \operatorname{class-in-building}_{c,h,b}  \text{ .}
    \end{align}

    Zunächst wird [[ref:eq:hinr]] behandelt. Auflösen der Implikation durh $a \Rightarrow b = \neg
a \vee b$ führt auf
    \begin{align}
    \label{eq:hinraufg}
    & \neg \operatorname{class-in-building}_{c,h,b} \vee
    \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
 &\vee h \neq \operatorname{first-hour}(\operatorname{day}(h)) \wedge \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b} \text{ , }
    \end{align}
    Jetzt wird eine Fallunterscheidung gemacht:
    1. $h$ ist die erste Stunde eines Tages. Dann ist [[ref:eq:hinraufg]]
       äquivalent zur Klausel in aussagenlogischer konjunktiver Normalform
       \begin{align}
        \label{eq:hinraufghnf}
        \neg \operatorname{class-in-building}_{c,h,b} \vee  \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
      \end{align}
    2. $h$ ist nicht die erste Stunde eines Tages. Dann ist [[ref:eq:hinraufg]] äquivalent zu
       \begin{align}
        \label{eq:hinraufgf}
         \neg \operatorname{class-in-building}_{c,h,b} \vee &
        \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
        \vee & \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b} \text{. }
       \end{align}
       Da aber $a \vee b \wedge c = (a \vee b) \wedge  (a \vee c)$ gilt, ist [[ref:eq:hinraufgf]] äquivalent
       zu den beiden Klauseln in konjunktiver Normalform
       \begin{align}
        \label{eq:hinraufgf1}
         \neg \operatorname{class-in-building}_{c,h,b} \vee &
        \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h}
        \\ \vee &  \neg \operatorname{teached-at}_{c,h}
       \end{align}
       und
       \begin{align}
        \label{eq:hinraufgf}
         \neg \operatorname{class-in-building}_{c,h,b} \vee &
        \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h}
        \\ \vee & \operatorname{class-in-building}_{c,h-1,b} \text{ . }
       \end{align}

    Damit ist die Kodierung der Hinrichtung in konjunktive Normalform abgeschlossen.

   Zur Rückrichtung:

    Auflösen der Implikation in [[ref:eq:rueckr]] führt auf
    \begin{align}
    \label{eq:rueckraufgeloest}
     &
    \neg \bigg(\bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
 &\vee h \neq \operatorname{first-hour}(\operatorname{day}(h)) \wedge \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b} \bigg) \nonumber \\
& \vee \operatorname{class-in-building}_{c,h,b} \text{, }
    \end{align}
    beziehungsweise
    \begin{align}
    \label{eq:rueckraufgeloestreingez}
      &
    \bigwedge_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)}  \neg \operatorname{occurs-at-hour}_{e,h} \nonumber \\
 &\wedge ( h = \operatorname{first-hour}(\operatorname{day}(h)) \vee \operatorname{teached-at}_{c,h} \vee   \neg \operatorname{class-in-building}_{c,h-1,b} ) \vee \nonumber \\ &\operatorname{class-in-building}_{c,h,b}  \text{, }
     \end{align}
     was äquivalent ist zu den Klauseln
     \begin{align*}
     &\neg \operatorname{occurs-at-hour}_{e,h} \vee \operatorname{class-in-building}_{c,h,b}\hspace{2mm} \\& \text{für } e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)
     \end{align*}
     und, falls $h$ nicht die erste Stunde eines Tages ist
     \[\operatorname{teached-at}_{c,h} \vee \neg \operatorname{class-in-building}_{c,h-1,b} \vee \operatorname{class-in-building}_{c,h,b} \text{ .}\]

     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       (defn class-in-building-relations
         [{:keys [events buildings num-days hours-per-day classes]}]
         (concat
          (for [[event {:keys [classes rooms]}] (events-to-schedule events)
                class classes
                day (range num-days)
                hour (range hours-per-day)]
            (implies (occurs-at-hour event [day hour])
                     (class-in-building class [day hour] (ffirst rooms))))
          (for [[building _] buildings
                [class _] classes
                :let [events
                      (for [[event {classes :classes rooms :rooms}] (events-to-schedule events)
                            :when (and (classes class) (= building (ffirst rooms)))]
                        event)]
                day (range num-days)
                hour (range hours-per-day)
                :let [event-occurrences (map #(occurs-at-hour % [day hour]) events)]
                clause (if (> hour 0)
                         [#{(negate (class-in-building class [day (dec hour)] building))
                             (teached-at class [day hour])
                             (class-in-building class [day hour] building)}
                          (implies (class-in-building class [day hour] building)
                                   (into #{} (concat event-occurrences
                                                     [(class-in-building class [day (dec hour)] building)])))
                          (implies (class-in-building class [day hour] building)
                                   (into #{} (concat event-occurrences
                                                     [(negate (teached-at class [day hour]))])))]
                         [(implies (class-in-building class [day hour] building)
                                   (into #{} event-occurrences))])]
            clause)))
     #+end_src

*** Minimierung der Wechsel zwischen Gebäuden für Lehrer
    Die Minimierung der Wechsel zwischen Gebäuden für Lehrer wird
    analog zur Minimierung der Gebäudewechsel für Klassen vorgestellt.
    Anstelle der Hilfsvariable class-in-building wird die Variable
    $\operatorname{teacher-in-building}$ verwendet.

     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       (defn teacher-in-building [teacher [day hour] building]
       (gen-var (symbol (str "teacher-in-building_" (name teacher) "_" day "_" hour "_" (name building)))))
     #+end_src

      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn minimize-building-changes-constraints-for-classes
        ([entities]  (minimize-building-changes-constraints-for-classes entities (partial * 20)))
        ([{:keys [classes buildings num-days hours-per-day distances]} cost-fn]
         (for [[class _] classes
               [building-1 _] buildings
               [building-2 _] buildings
               :let [distance (get distances [building-1 building-2] 0)]
               :when (and (not= building-1 building-2) (> distance 0))
               day (range num-days)
               hour (range (dec hours-per-day))]
           [#{(negate (class-in-building class [day hour] building-1))
              (negate (class-in-building class [day (inc hour)] building-2))}
            (cost-fn distance)])))
     #+end_src

     Die logische Äquivalenz für $\operatorname{teacher-in-building}$
     ist die gleiche wie für $\operatorname{class-in-building}$, wobei
     aber anstatt der Variable $\operatorname{teached-at}$ die
     Variable $\operatorname{teaches-at}$ für Lehrer benutzt wird. Da
     die Umformungen zur konjunktiven Normalform völlig identisch
     sind, werden hier nur die Ergebnisse angegeben. Für jeden Lehrer
     $t$, Zeit $h$ und Gebäude $b$ gelten die folgenden Klauseln:
     \begin{align}
        \label{eq:teacherinbuilding1}
        \neg \operatorname{teacher-in-building}_{t,h,b} \vee  \bigvee_{e \in \operatorname{Events},t \in \operatorname{teacers}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
      \end{align}
           \[\neg \operatorname{occurs-at-hour}_{e,h} \hspace{2mm} \text{für } e \in \operatorname{Events},t \in \operatorname{teachers}(e), b = \operatorname{building}(e)\]
           Wenn $h$ nicht die erste Stunde eines Tages ist, kommen außerdem noch folgende Klauseln hinzu:
      \begin{align}
        \label{eq:teacher-in-building-2}
         \neg \operatorname{teacher-in-building}_{t,h,b} \vee &
        \bigvee_{e \in \operatorname{Events},t \in \operatorname{teachers}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
        \vee &  \neg \operatorname{teaches-at}_{t,h}
       \end{align}
      \begin{align}
        \label{eq:hinraufgf}
         \neg \operatorname{teacher-in-building}_{t,h,b} \vee &
        \bigvee_{e \in \operatorname{Events},t \in \operatorname{teachers}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
        \vee &  \operatorname{teacher-in-building}_{t,h-1,b} \text{ ,}
       \end{align}
           \[\operatorname{teaches-at}_{t,h} \vee \neg \operatorname{teacher-in-building}_{t,h-1,b} \vee \operatorname{teacher-in-building}_{t,h,b} \text{ .}\]
     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       (defn teacher-in-building-relations
         [{:keys [events buildings num-days hours-per-day teachers]}]
         (concat
          (for [[event {:keys [teachers rooms]}] (events-to-schedule events)
                teacher teachers
                day (range num-days)
                hour (range hours-per-day)]
            (implies (occurs-at-hour event [day hour])
                     (teacher-in-building teacher [day hour] (ffirst rooms))))
          (for [[building _] buildings
                [teacher _] teachers
                :let [events
                      (for [[event {teachers :teachers rooms :rooms}] (events-to-schedule events)
                            :when (and (teachers teacher) (= building (ffirst rooms)))]
                        event)]
                day (range num-days)
                hour (range hours-per-day)
                :let [event-occurrences (map #(occurs-at-hour % [day hour]) events)]
                clause (if (> hour 0)
                         [#{(negate (teacher-in-building teacher [day (dec hour)] building))
                             (teaches-at teacher [day hour])
                             (teacher-in-building teacher [day hour] building)}
                          (implies (teacher-in-building teacher [day hour] building)
                                   (into #{} (concat event-occurrences
                                                     [(teacher-in-building teacher [day (dec hour)] building)])))
                          (implies (teacher-in-building teacher [day hour] building)
                                   (into #{} (concat event-occurrences
                                                     [(negate (teaches-at teacher [day hour]))])))]
                         [(implies (teacher-in-building teacher [day hour] building)
                                   (into #{} event-occurrences))])]
            clause)))



     #+end_src

     #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
       (defn minimize-building-changes-constraints-for-teachers
         ([entities]  (minimize-building-changes-constraints-for-teachers entities (partial * 20)))
         ([{:keys [teachers buildings num-days hours-per-day distances]} cost-fn]
          (for [[teacher _] teachers
                [building-1 _] buildings
                [building-2 _] buildings
                :let [distance (get distances [building-1 building-2] 0)]
                :when (and (not= building-1 building-2) (> distance 0))
                day (range num-days)
                hour (range (dec hours-per-day))]
            [#{(negate (teacher-in-building teacher [day hour] building-1))
               (negate (teacher-in-building teacher [day (inc hour)] building-2))}
             (cost-fn distance)])))
     #+end_src

**** DONE Optimal constraints                                      :noexport:
     CLOSED: [2015-05-23 Sat 15:27]
     - anpassen neue Funktionen aufnehmen und umbenennen
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
          (def optimal-constraint-functions
              (concat constraint-functions
                      [#'minimize-gaps-for-classes-constraints
                       #'minimize-gaps-for-teachers-constraints
                       #'class-in-building-relations
                       #'teacher-in-building-relations
                       #'minimize-building-changes-constraints-for-classes
                       #'minimize-building-changes-constraints-for-teachers]))

            (defn solve-problem-optimally [entities]
              (solve-problem entities {:constraint-functions optimal-constraint-functions :maxsat? true}))

              (deftest test-solves
      (is (not (nil? (solve-problem example-entities))))
      (is (not (nil? (solve-problem bigger-example-entities)))))
    #+end_src
*** Ergebnisse
    Die Optimalitätsbedingung, im Stundenplan möglichst wenig Lücken
    zu haben, wird an folgendem Beispiel illustriert:
    - Eine Klasse.
    - Ein Lehrer.
    - Ein Raum.
    - Die Klasse braucht 3 Stunden Mathe bei Lehrer 1 in Raum 1.
    - Es gibt einen Tag mit 10 Stunden.
    - Raum 1 ist nicht verfügbar an der ersten, dritten, sechsten und siebten Stunde.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def minimize-gaps-example-entities
        {
         :classes {:class-1 {}}
         :teachers {:teacher-1 {}}
         :buildings {:building-1 {:room-1 {:times-not-available #{[0 0] [0 2] [0 5] [0 6]}}}}
         :num-days 1
         :hours-per-day 10
         :distances {}
         :events
         {:class-1-math
          (create-event :classes :class-1 :rooms #{[:building-1 :room-1]}
                        :teachers #{:teacher-1} :number-of-times 3)}})
    #+end_src


    Der Stundenplan in Abbildung [[ref:fig:not-minimize-gaps]] ist
    /zulässig/ und wurde durch Erfüllung aller harten Klauseln durch
    einen SAT-Solver erstellt. Wie man an dem Beispiel sieht, ist
    dieser Stundenplan aber nicht optimal, da es möglich ist, die drei
    Mathestunden für Klasse 1 in die letzten drei Stunden zu legen
    ohne den Raum in einer nicht verfügbaren Stunde zu belegen.

    #+CAPTION: Zulässiger Stundenplan
    #+LABEL: fig:not-minimize-gaps
    #+ATTR_LaTeX: :width 200px
    [[/home/kima/programming/timetabling/images/bigger-example-entities-easy-problem-no-optimisation-minimize-gaps-example.png]]

    Gibt man auch die weichen Klauseln einem Weighted Partial MAX-SAT
    Solver, so erhält man den Stundenplan in Abbildung [[ref:fig:minimize-gaps]].
    Man sieht, dass der Solver den optimalen Stundenplan generieren konnte.

    #+Caption: Optimaler Stundenplan
    #+LABEL: fig:minimize-gaps
    #+ATTR_LaTeX: :width 200px
    [[/home/kima/programming/timetabling/images/bigger-example-entities-easy-problem-with-optimisation-minimize-gaps-example.png]]


    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (deftest test-minimize-gaps-example
        (is (= {:classes {:class-1 {}}, :teachers {:teacher-1 {}}, :buildings {:building-1 {:room-1 {:times-not-available #{[0 0] [0 6] [0 5] [0 2]}}}}, :num-days 1, :hours-per-day 10, :distances {}, :events {:class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1], :allowed-rooms :all, :times [[0 3] [0 7] [0 9]]}}}
               (solve-problem minimize-gaps-example-entities)))
        (is (= {:classes {:class-1 {}}, :teachers {:teacher-1 {}}, :buildings {:building-1 {:room-1 {:times-not-available #{[0 0] [0 6] [0 5] [0 2]}}}}, :num-days 1, :hours-per-day 10, :distances {}, :events {:class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1], :allowed-rooms :all, :times [[0 9] [0 8] [0 7]]}}}
               (solve-problem-optimally minimize-gaps-example-entities))))


      (test-minimize-gaps-example)
    #+end_src

    Die Auswirkungen der Optimalitätsbedingung zur Minimierung von
    Gebäudewechseln sieht man an dem folgenden Beispiel:
    - Eine Klasse.
    - Einen Lehrer.
    - Drei Gebäude mit je einem Raum.
    - Um zwischen Gebäude 1 und 3 und zwischen 2 und 3 zu reisen,
      braucht es eine Stunde, zwischen Gebäude 1 und 2 jedoch zwei
      Stunden.
    - Einen Tag mit 10 Stunden
    - Je 2 Stunden Mathe, Deutsch und Kunst für Klasse 1, welche von
      Lehrer 1 gegeben werden und im Gebäude 1,2 beziehungsweise 3
      stattfinden.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def minimize-buildings-example
        {
         :classes {:class-1 {}}
         :teachers {:teacher-1 {}}
         :buildings {:building-1 {:room-1 {}}
                     :building-2 {:room-1 {}}
                     :building-3 {:room-1 {}}}
         :distances {[:building-1 :building-2] 2
                     [:building-2 :building-1] 2
                     [:building-1 :building-3] 1
                     [:building-3 :building-1] 1
                     [:building-2 :building-3] 1
                     [:building-3 :building-2] 1}
         :num-days 1
         :hours-per-day 10
         :events {:class-1-math
                  (create-event :classes :class-1 :rooms #{[:building-1 :room-1]}
                                :teachers #{:teacher-1} :number-of-times 2)
                  :class-1-german
                  (create-event :classes :class-1 :rooms #{[:building-2 :room-1]}
                                :teachers #{:teacher-1} :number-of-times 2)
                  :class-1-art
                  (create-event :classes :class-1 :rooms #{[:building-3 :room-1]}
                                :teachers #{:teacher-1} :number-of-times 2)}})
    #+end_src

    Eine /zulässige/ Lösung des Problems ist in Abbildung
    [[ref:fig:building-example-no-optimisation]] dargestellt. Wieder sieht
    man, dass sie nicht optimal ist, da man weniger Zeiten zum
    Wechseln für Gebäude braucht, wenn man nicht von Gebäude 1 zu
    Gebäude 2 wechselt, sondern von Gebäude 3.

    #+CAPTION: Zulässiger Stundenplan.
    #+LABEL: fig:building-example-no-optimisation
    #+ATTR_LaTex: :width 200px
    [[/home/kima/programming/timetabling/images/bigger-example-entities-easy-problem-no-optimisation-minimize-building-changes-example.png]]

    Mit den weichen Klauseln liefert der Weighted Partial MAX-SAT
    Solver eine optimale Lösung, welche in Abbildung
    [[ref:fig:building-example-with-optimisation]] dargestellt ist. Wie
    erwartet, wurde hier von Gebäude 3 zu Gebäude 2 gewechselt und so
    sind insgesamt nur 2 Stunden durch Gebäudewechsel weggefallen.

    #+CAPTION: Optimaler Stundenplan.
    #+LABEL: fig:building-example-with-optimisation
    #+ATTR_LaTeX: :width 200px
    [[/home/kima/programming/timetabling/images/bigger-example-entities-easy-problem-with-optimisation-minimize-building-changes-example.png]]


    Für das im letzten Abschnitt vorgestellte größere/realistische
    Beispielproblem wurden zusammen mit den beschriebenen
    Optimalitätsbedingungen insgesamt eine Formel mit 331818 Klauseln
    erzeugt. Diese Formel wurde dem Open-wbo Weighted Partial MAX-SAT
    solver übergeben, welcher nach einer Minute abgebrochen wurde.
    #+BEGIN_LATEX
    \footnote{Der
    Open-wbo solver lief dabei mit Standarteinstellungen auf einem
    Lenovo W550s Laptop mit einem Intel® Core™ i7 Prozessor mit 16GB Arbeitsspeicher.
    Dies gilt auch für andere angegebene Laufzeiten in dieser Arbeit.}
    #+END_LATEX

    Bei der gefundenen Variablenzuweisung beträgt die
    Summe der Gewichte der weichen Klauseln 200.

    Bei dem in diesem Durchlauf erstellten Stundenplan kann man die
    Resultate der Optimierung gut am Stundenplan der Klasse 11 sehen,
    welcher in Abbildung [[ref:fig:optimal-class-11]] dargestellt ist.

    #+CAPTION: Stundenplan für Klasse 11 nach 60 Sekunden Optimierung.
    #+LABEL: fig:optimal-class-11
    #+ATTR_LaTeX: :width 400px
    [[/home/kima/programming/timetabling/images/bigger-example-entities-easy-problem-with-optimisation-class-11.png]]

    Klassenraum der Klasse 11 ist der Raum 6 im Gebäude 1. Die Klasse
    muss daher zum Sport und zum Werken Gebäude wechseln. An Tagen 0,1,3
    und 4 schafft es der Stundenplan für die Klasse ohne Lücken und
    Gebäudewechsel auszukommen. Lediglich am Tag 2 muss sie einmal zum
    Werken das Gebäude wechseln. Man sieht, dass der Stundenplan
    hinsichtlich der Optimalitätskriterien noch weiter optimiert werden
    könnte, indem die Werkstunde am Tag2 direkt angrenzend an die
    Werkstunde am Tag1 gelegt würde. Das gute Verteilen der Zeiten für
    die Werkstunden ist bei diesem Problem durch die hohe Auslastung des
    Werkraums allerdings schwierig. Die Auslastung des Werkraumes ist in Abbildung
    [[ref:fig:werkraumauslastung]] dargestellt.

    #+CAPTION: Werkraumauslastung
    #+LABEL: fig:werkraumauslastung
    #+ATTR_LaTeX: :width 400px
    [[/home/kima/programming/timetabling/images/bigger-example-entities-easy-problem-with-optimisation-werkraum.png]]

 #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
   (def bigger-example-optimal-results
     {:classes {:class-4 {:class-teacher :teacher-4, :class-room [:building-2 :room-2]}, :class-10 {:class-teacher :teacher-10, :class-room [:building-2 :room-5]}, :class-11 {:class-teacher :teacher-11, :class-room [:building-1 :room-6]}, :class-8 {:class-teacher :teacher-8, :class-room [:building-2 :room-4]}, :class-2 {:class-teacher :teacher-2, :class-room [:building-2 :room-1]}, :class-12 {:class-teacher :teacher-12, :class-room [:building-2 :room-6]}, :class-3 {:class-teacher :teacher-3, :class-room [:building-1 :room-2]}, :class-5 {:class-teacher :teacher-5, :class-room [:building-1 :room-3]}, :class-1 {:class-teacher :teacher-1, :class-room [:building-1 :room-1]}, :class-7 {:class-teacher :teacher-7, :class-room [:building-1 :room-4]}, :class-6 {:class-teacher :teacher-6, :class-room [:building-2 :room-3]}, :class-9 {:class-teacher :teacher-9, :class-room [:building-1 :room-5]}}, :events {:class-9-werken {:classes #{:class-9}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-9} #{:teacher-9}], :durations [1 1], :allowed-rooms :all, :times [[2 5] [1 2]]}, :class-2-werken {:classes #{:class-2}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :allowed-rooms :all, :times [[0 0] [0 2]]}, :class-10-sport {:classes #{:class-10}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[3 3]]}, :class-5-art {:classes #{:class-5}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-5} #{:teacher-5}], :durations [1 1], :allowed-rooms :all, :times [[2 2] [2 0]]}, :class-3-german {:classes #{:class-3}, :rooms [#{[:building-1 :room-2]} #{[:building-1 :room-2]} #{[:building-1 :room-2]} #{[:building-1 :room-2]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 1] [4 3] [4 2] [1 0]]}, :class-7-werken {:classes #{:class-7}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-7} #{:teacher-7}], :durations [1 1], :allowed-rooms :all, :times [[0 5] [1 5]]}, :class-3-math {:classes #{:class-3}, :rooms [#{[:building-1 :room-2]} #{[:building-1 :room-2]} #{[:building-1 :room-2]} #{[:building-1 :room-2]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 4] [3 5] [1 5] [2 5]]}, :class-2-art {:classes #{:class-2}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :allowed-rooms :all, :times [[3 0] [4 5]]}, :class-3-werken {:classes #{:class-3}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-3} #{:teacher-3}], :durations [1 1], :allowed-rooms :all, :times [[2 2] [2 3]]}, :class-1-sk {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :allowed-rooms :all, :times [[2 5] [2 4] [0 3] [0 2]]}, :class-8-math {:classes #{:class-8}, :rooms [#{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-4]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 5] [2 2] [0 3] [2 1]]}, :class-1-art {:classes #{:class-1}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :allowed-rooms :all, :times [[0 4] [1 5]]}, :class-6-werken {:classes #{:class-6}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-6} #{:teacher-6}], :durations [1 1], :allowed-rooms :all, :times [[3 0] [4 2]]}, :class-10-art {:classes #{:class-10}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-10} #{:teacher-10}], :durations [1 1], :allowed-rooms :all, :times [[2 3] [4 3]]}, :class-9-sport {:classes #{:class-9}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[2 2]]}, :class-12-art {:classes #{:class-12}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-12} #{:teacher-12}], :durations [1 1], :allowed-rooms :all, :times [[1 1] [1 2]]}, :class-1-sport {:classes #{:class-1}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[1 2]]}, :class-9-art {:classes #{:class-9}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-9} #{:teacher-9}], :durations [1 1], :allowed-rooms :all, :times [[0 5] [0 2]]}, :class-10-werken {:classes #{:class-10}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-10} #{:teacher-10}], :durations [1 1], :allowed-rooms :all, :times [[0 3] [1 0]]}, :class-8-sport {:classes #{:class-8}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[1 0]]}, :class-3-sk {:classes #{:class-3}, :rooms [#{[:building-1 :room-2]} #{[:building-1 :room-2]} #{[:building-1 :room-2]} #{[:building-1 :room-2]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :allowed-rooms :all, :times [[3 4] [3 2] [2 0] [1 2]]}, :class-11-werken {:classes #{:class-11}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-11} #{:teacher-11}], :durations [1 1], :allowed-rooms :all, :times [[1 4] [2 4]]}, :class-7-math {:classes #{:class-7}, :rooms [#{[:building-1 :room-4]} #{[:building-1 :room-4]} #{[:building-1 :room-4]} #{[:building-1 :room-4]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :allowed-rooms :all, :times [[2 2] [2 3] [4 1] [3 5]]}, :class-8-art {:classes #{:class-8}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-8} #{:teacher-8}], :durations [1 1], :allowed-rooms :all, :times [[4 2] [0 0]]}, :class-4-art {:classes #{:class-4}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-4} #{:teacher-4}], :durations [1 1], :allowed-rooms :all, :times [[3 4] [0 3]]}, :class-7-german {:classes #{:class-7}, :rooms [#{[:building-1 :room-4]} #{[:building-1 :room-4]} #{[:building-1 :room-4]} #{[:building-1 :room-4]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 4] [2 5] [4 5] [0 2]]}, :class-6-sport {:classes #{:class-6}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[0 4]]}, :class-11-sport {:classes #{:class-11}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[4 1]]}, :class-2-german {:classes #{:class-2}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 0] [1 5] [3 3] [0 1]]}, :class-7-art {:classes #{:class-7}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-7} #{:teacher-7}], :durations [1 1], :allowed-rooms :all, :times [[2 4] [1 0]]}, :class-4-math {:classes #{:class-4}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-2]} #{[:building-2 :room-2]} #{[:building-2 :room-2]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 0] [2 4] [4 2] [1 3]]}, :class-6-german {:classes #{:class-6}, :rooms [#{[:building-2 :room-3]} #{[:building-2 :room-3]} #{[:building-2 :room-3]} #{[:building-2 :room-3]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 4] [0 0] [4 1] [3 3]]}, :class-4-german {:classes #{:class-4}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-2]} #{[:building-2 :room-2]} #{[:building-2 :room-2]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :allowed-rooms :all, :times [[2 3] [1 5] [1 4] [1 2]]}, :class-1-german {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 4] [4 5] [4 2] [3 0]]}, :class-11-math {:classes #{:class-11}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-1 :room-6]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 3] [0 2] [3 3] [3 1]]}, :class-11-art {:classes #{:class-11}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-11} #{:teacher-11}], :durations [1 1], :allowed-rooms :all, :times [[2 1] [0 1]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 2] [2 0] [1 3] [4 3]]}, :class-12-werken {:classes #{:class-12}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-12} #{:teacher-12}], :durations [1 1], :allowed-rooms :all, :times [[0 1] [3 1]]}, :class-6-sk {:classes #{:class-6}, :rooms [#{[:building-2 :room-3]} #{[:building-2 :room-3]} #{[:building-2 :room-3]} #{[:building-2 :room-3]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 0] [3 2] [1 5] [2 1]]}, :class-4-sport {:classes #{:class-4}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[2 0]]}, :class-11-sk {:classes #{:class-11}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-1 :room-6]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 0] [2 2] [2 0] [0 4]]}, :class-2-sport {:classes #{:class-2}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[2 4]]}, :class-2-sk {:classes #{:class-2}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 1] [4 1] [0 5] [0 3]]}, :class-8-werken {:classes #{:class-8}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-8} #{:teacher-8}], :durations [1 1], :allowed-rooms :all, :times [[2 0] [0 4]]}, :class-5-werken {:classes #{:class-5}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-5} #{:teacher-5}], :durations [1 1], :allowed-rooms :all, :times [[3 3] [1 3]]}, :class-12-sk {:classes #{:class-12}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-6]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 2] [4 4] [0 0] [2 0]]}, :class-3-sport {:classes #{:class-3}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[0 0]]}, :class-7-sport {:classes #{:class-7}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[3 1]]}, :class-12-math {:classes #{:class-12}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-6]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 3] [2 4] [4 2] [2 2]]}, :class-4-werken {:classes #{:class-4}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-4} #{:teacher-4}], :durations [1 1], :allowed-rooms :all, :times [[1 1] [4 5]]}, :class-10-math {:classes #{:class-10}, :rooms [#{[:building-2 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-5]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 1] [4 5] [0 4] [3 0]]}, :class-5-sk {:classes #{:class-5}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-1 :room-3]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 5] [3 0] [1 5] [2 5]]}, :class-9-german {:classes #{:class-9}, :rooms [#{[:building-1 :room-5]} #{[:building-1 :room-5]} #{[:building-1 :room-5]} #{[:building-1 :room-5]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 0] [3 4] [3 0] [3 1]]}, :class-3-art {:classes #{:class-3}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-3} #{:teacher-3}], :durations [1 1], :allowed-rooms :all, :times [[3 3] [1 4]]}, :class-9-sk {:classes #{:class-9}, :rooms [#{[:building-1 :room-5]} #{[:building-1 :room-5]} #{[:building-1 :room-5]} #{[:building-1 :room-5]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :allowed-rooms :all, :times [[3 2] [3 5] [3 3] [1 5]]}, :class-11-german {:classes #{:class-11}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-1 :room-6]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :allowed-rooms :all, :times [[3 5] [3 2] [3 4] [3 0]]}, :class-4-sk {:classes #{:class-4}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-2]} #{[:building-2 :room-2]} #{[:building-2 :room-2]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 0] [4 4] [4 3] [4 1]]}, :class-5-sport {:classes #{:class-5}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[4 4]]}, :class-6-art {:classes #{:class-6}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-6} #{:teacher-6}], :durations [1 1], :allowed-rooms :all, :times [[3 5] [2 5]]}, :class-9-math {:classes #{:class-9}, :rooms [#{[:building-1 :room-5]} #{[:building-1 :room-5]} #{[:building-1 :room-5]} #{[:building-1 :room-5]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 0] [0 4] [0 1] [0 3]]}, :class-8-german {:classes #{:class-8}, :rooms [#{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-4]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :allowed-rooms :all, :times [[3 4] [3 0] [3 5] [3 1]]}, :class-1-werken {:classes #{:class-1}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :allowed-rooms :all, :times [[2 1] [3 5]]}, :class-5-math {:classes #{:class-5}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-1 :room-3]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 0] [0 1] [1 1] [0 2]]}, :class-10-german {:classes #{:class-10}, :rooms [#{[:building-2 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-5]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :allowed-rooms :all, :times [[0 0] [0 1] [0 2] [2 1]]}, :class-7-sk {:classes #{:class-7}, :rooms [#{[:building-1 :room-4]} #{[:building-1 :room-4]} #{[:building-1 :room-4]} #{[:building-1 :room-4]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 3] [1 1] [0 3] [0 0]]}, :class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :allowed-rooms :all, :times [[2 3] [0 5] [0 0] [0 1]]}, :class-12-german {:classes #{:class-12}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-6]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 5] [0 4] [2 5] [0 3]]}, :class-6-math {:classes #{:class-6}, :rooms [#{[:building-2 :room-3]} #{[:building-2 :room-3]} #{[:building-2 :room-3]} #{[:building-2 :room-3]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :allowed-rooms :all, :times [[4 5] [4 3] [3 1] [2 0]]}, :class-5-german {:classes #{:class-5}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-1 :room-3]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :allowed-rooms :all, :times [[2 3] [0 3] [0 4] [0 0]]}, :class-8-sk {:classes #{:class-8}, :rooms [#{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-4]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :allowed-rooms :all, :times [[3 2] [2 4] [2 3] [0 2]]}, :class-12-sport {:classes #{:class-12}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :allowed-rooms :all, :times [[1 4]]}, :class-10-sk {:classes #{:class-10}, :rooms [#{[:building-2 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-5]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :allowed-rooms :all, :times [[1 5] [1 4] [2 0] [4 0]]}}, :buildings {:building-1 {:room-1 {}, :room-2 {}, :room-3 {}, :room-4 {}, :room-5 {}, :room-6 {}, :art-room {}}, :building-2 {:room-1 {}, :room-2 {}, :room-3 {}, :room-4 {}, :room-5 {}, :room-6 {}, :werkraum {}}, :sporthalle {:sporthalle {}}}, :num-days 5, :hours-per-day 6, :teachers {:teacher-7 {}, :teacher-6 {}, :teacher-10 {}, :teacher-1 {}, :teacher-11 {}, :sportlehrer {}, :teacher-4 {}, :teacher-2 {}, :teacher-12 {}, :teacher-8 {}, :teacher-3 {}, :teacher-5 {}, :teacher-9 {}}, :distances {[:building-1 :sporthalle] 1, [:sporthalle :building-2] 1, [:sporthalle :building-1] 1, [:building-2 :sporthalle] 1, [:building-2 :building-1] 1, [:building-1 :building-2] 1}})
 #+end_src

  Dies ist ein erfreuliches Ergebnis, da es zeigt, dass der hier
  vorgestellte Ansatz zumindest für das Teilproblem in dem alle Räume
  der Events bekannt sind, noch gut mit einem Beispielproblem in
  realistischer Größe umgehen kann. 

*** Untersuchung der Skalierbarkeit
    Um ebenso die Minimierung von Lücken im Stundenplan von Lehrern
    und Klassen testen zu können, wird das oben vorgestellte
    skalierbare Problem in dierem Abschnitt verändert, sodass jede
    Klasse nicht mehr 35, sondern 34 Veranstaltungen pro Woche hat.
    Damit der erzeugte Stundenplan optimal ist, muss dadurch die freie
    Stunde für jede Klasse am Anfang oder am Ende eines Tages
    platziert werden.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn create-scalable-optimizeable-problem [num-hours num-days num-classes]
        (let [num-slots (* num-days num-hours)]
          {:classes (reduce #(assoc %1 (keyword (str "class-" %2))
                                    {:class-teacher (keyword (str "teacher-" %2))
                                     :class-room [(keyword (str "building-" %2)) :room-1]})
                            {} (range num-classes))
           :teachers (reduce #(assoc %1 (keyword (str "teacher-" %2)) {}) {} (range num-classes))
           :distances {}
           :num-days num-days
           :hours-per-day num-hours
           :buildings (reduce #(assoc %1 (keyword (str "building-" %2)) {:room-1 {}})
                              {} (range num-classes))
           :events (reduce #(assoc %1 (keyword (str "ef-" %2))
                                   (create-event :classes (keyword (str "class-" %2))
                                                 :rooms #{[(keyword (str "building-" %2)) :room-1]}
                                                 :teachers #{(keyword (str "teacher-" %2))}
                                                 :number-of-times (dec num-slots)))
                           {} (range num-classes))}))
    #+end_src

    #+CAPTION: Anzahl erzeugter Klauseln und Laufzeit des Solvers bei unterschiedlicher Klassenzahl
    #+NAME: tab:scalable-optimal
   | Klassen | Klauseln | Laufzeit (s) des Solvers | Gewichtung |
   |---------+----------+--------------------------+------------|
   |      10 |   935610 | 18                       |          0 |
   |      20 |  1909220 | 74.3                     |          0 |
   |      30 |  2920830 | 273,2                    |          0 |
   |      40 |  3970440 | TIMEOUT                  |         44 |
   |      50 |  5058050 | TIMEOUT                  |         56 |
   |      60 |  6183660 | TIMEOUT                  |         68 |

   Tabelle [[ref:tab:scalable-optimal]] zeigt auf, wie die Erzeugung eines
   optimalen Stundenplans skaliert. Dabei wurde der Solver nach 5
   Minuten abgebrochen und die Gewichtung der bis dahin besten
   zulässigen Lösung in der letzten Spalte angezeigt. Bis zur
   Eingabgegröße 30 konnte ein optimaler Stundenplan innerhalb von 5
   Minuten erzeugt werden und auch bei der Eingabgegröße 60 wurde
   innerhalb der 5 Minuten noch ein zulässiger Stundenplan gefunden,
   welcher aber nicht weiter als zur Gewichtung 68 innerhalb der Zeit
   optimiert werden konnte.


* Erweiterung des Teilproblems um Raumplanung
  Nachdem zulässige und optimale Stundenpläne, bei denen nur die
  Zeiten der Veranstaltungen verplant werden müssen, erzeugt werden
  können und die Untersuchung der Skalierbarkeit guten Grund für die
  Annahme, dass das Programm auch noch mit viel größeren Problemem in
  annehmbarer Zeit fertig wird geben hat, wird nun dieses Teilproblem
  erweitert, indem die Bedingung, dass die Raumbelegung aller Events
  schon bekannt ist, fallengelassen wird.

  Trotzdem steht bei einigen Veranstaltungen fest, in welchen Räumen
  sie stattfinden sollen, beziehungsweise, dass nur wenige Räume in
  Frage kommen. Das beste Beispiel dafür ist der Sportunterricht, der
  immer in der Sporthalle stattfinden muss.

  Die oben beschriebenen $\operatorname{occurs-at-room}$ Variablen
  werden dabei nützlich sein. Bisher wurden sie für alle Räume auf
  einen festen Wert gesetzt, welcher von der festen Belegungszuweisung
  der Räume diktiert wurde.

  Auch hier wird zunächst nur die Erzeugung eines zulässigen
  Stundenplans betrachtet und darauf aufbauend die
  Optimalitätsbedingungen von oben angepasst, sodass sie für diese
  erweiterte Situation eingesetzt werden können.

  Die Schwierigkeit besteht nun darin, dass der Operator
  $\operatorname{rooms}(e)$ eines Events $e$ nichtmehr bekannt ist.
  Alle diesen Operator benutzenden Klauseln müssen daher angepasst
  werden.
** Erzeugung eines zulässigen Stundenplans
*** Jedes Event muss einem Raum zugeordnet sein
    Analog zu der Bedingung, dass eine Veranstaltung an genau einer
    Zeit stattfindet, wird die Bedingung gestellt, dass eine
    Veranstaltung genau einem Raum zugeordnet ist.

    Für jedes Event $e$ wird also folgende Bedingung gestellt:

    \[\operatorname{exactly}(\{\operatorname{occurs-at-room}_{e,r} | r
    \in \operatorname{Rooms} \},1) \]

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn everything-exactly-one-room-constraints
        [{:keys [events buildings]}]
        (for [[event _] (events-to-schedule events)
              clause (exactly (for [[building rooms] buildings
                                    [room _] rooms]
                                (occurs-at-room event [building room])) 1)]
          clause))
    #+end_src
*** Eingrenzung der Raumwahl
    Nicht jedes Event kann in allen Räumen stattfinden, zum Beispiel
    ist es nicht sinnvoll, Mathe in der Sporthalle abzuhalten, obwohl
    man vielleicht mit dem Boden eine sehr große Tafel hätte.

    Daher wird für jedes Event $e$ und für jeden Raum $r$, in dem das
    Event nicht stattfinden soll, die Klausel

    \[\neg \operatorname{occurs-at-room}_{e,r}\]

    erzeugt.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn forbidden-rooms-constraints
        [{:keys [events]}]
        (for [[event details] (events-to-schedule events)
              forbidden-room (:forbidden-rooms details)]
          #{(negate (occurs-at-room event forbidden-room))}))
    #+end_src

*** Verhindern von Doppelbelegungen von Räumen
    Bei der oben vorgestellten Kodierung der Bedingung zur
    Verhinderung von Doppelbelegungen von Räumen wurde angenommen,
    dass die Zuordnung von Events zu Räumen bekannt ist. Da dies in
    dieser Situation nicht mehr der Fall ist, muss sie angepasst
    werden.

    In [[cite:ttpsat]] werden Doppelbelegungen verhindert, in dem die
    folgenden Klauseln für unterschiedliche Events $e$, $e'$, für jeden
    Raum $r$ und Stunde $h$ erzeugt werden:

    \[\neg \operatorname{occurs-at-hour}_{e,h}
    \vee \operatorname{occurs-at-hour}_{e',h} \vee \neg
    \operatorname{occurs-at-room}_{e,r} \vee \neg
    \operatorname{occurs-at-room}_{e',r}\]

    Die Idee hinter dieser Klausel wird klar, wenn man bemerkt, dass
    sie durch Umformung aus [[ref:eq:wirklich]] entsteht.

    \begin{align}
    \label{eq:wirklich}
    &\forall h \in \operatorname{Hours} \nonumber \\
    &(\operatorname{occurs-at-hour}_{e,h} \wedge \operatorname{occurs-at-room}_{e,r}) \Rightarrow
      \neg (\operatorname{occurs-at-hour}_{e', h} \wedge \operatorname{occurs-at-room}_{e', r})
    \end{align}

    Es gilt nämlich
    \begin{align*}
    &(\operatorname{occurs-at-hour}_{e,h} \wedge \operatorname{occurs-at-room}_{e,r}) \Rightarrow
    \neg (\operatorname{occurs-at-hour}_{e', h} \wedge \operatorname{occurs-at-room}_{e', r})  \\
    = &\neg (\operatorname{occurs-at-hour}_{e,h} \wedge \operatorname{occurs-at-room}_{e,r}) \vee
    \neg (\operatorname{occurs-at-hour}_{e', h} \wedge \operatorname{occurs-at-room}_{e', r}) \\
    = &\neg \operatorname{occurs-at-hour}_{e,h}
    \vee \operatorname{occurs-at-hour}_{e',h} \vee \neg
    \operatorname{occurs-at-room}_{e,r} \vee \neg
    \operatorname{occurs-at-room}_{e',r}\text{ .}
    \end{align*}

    Bedingung [[ref:eq:wirklich]] lässt sich gut interpretieren:

    Wenn ein Event, das in dem Raum $r$ unterrichtet wird, zur Zeit
    $h$ stattfindet, folgt daraus, dass kein anderes Event, das in
    dem gleichen Raum unterrichtet wird, auch zur Zeit $h$ stattfindet.

    Diese Bedingung zu stellen, erzeugt allerdings sehr viele Klauseln,
    da die Anzahl der Bedingungen quadratisch von der Anzahl aller zu
    verplanenden Events abhängt. Da aber die Anzahl dieser
    Veranstaltungen bei einer 12-zügigen Grundschule schon ziemlich
    groß ist (Bei dem beschriebenen größeren Beispielproblem schon
    204), lohnt es sich, eine effizientere Kodierung zu suchen.

    Die Idee für eine effizientere Kodierung dieser Bedingung kommt
    aus der Beobachtung, dass man [[ref:eq:wirklich]] durch eine $\operatorname{at-most}$
    Kardinaltiätsbedingung formulieren kann, nämlich dass es für höchstens 1
    Event sein kann, dass es zu gegebener Zeit $h$ in dem Raum $r$
    stattfindet.

    Die hier vorgestellte Kodierung der höchstens 1
    Kardinaltiätsbedingung ist im Gegensatz zu [[ref:eq:wirklich]] nicht
    Quadratisch in Bezug auf die Anzahl der Variablen, sondern
    *linear*.

    Um die Bedingung zum Verhindern von Doppelbelegungen als at-most
    Kardinaltätsbedingung zu formulieren, muss eine neue Variable
    eingeführt werden:

    Für alle Räume $r$ und Zeiten $h$ sowie für jedes Event $e$ gibt es eine Variable


    \[\operatorname{occurs-at-room-at-hour}_{e,r,h} \text{ ,}\]


    welche besagt, dass $e$ zur Zeit $h$ in $r$ stattfinet.

   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn occurs-at-room-at-hour
        [event [building room] [day hour]]
        (gen-var (symbol (str "occurs-at-handr_" (name event) "_" (name building) "_" (name room) "_" day "_" hour))))
    #+end_src


    Die Beziehung zwischen occurs-at-hour und occurs-at-room sind klar:

    \[\operatorname{occurs-at-room-at-hour}_{e,r,h} \Leftrightarrow
      \operatorname{occurs-at-room}_{e,r} \wedge \operatorname{occurs-at-hour}_{e,h}\]

    Als Klauseln in konjunktiver Normalform ergeben sich aus dieser Äqivalenz

    \[\neg \operatorname{occurs-at-room-at-hour}_{e,r,h} \vee \operatorname{occurs-at-hour}_{e,h}\]
    \[\neg \operatorname{occurs-at-room-at-hour}_{e,r,h} \vee \operatorname{occurs-at-room}_{e,r} \text{ ,}\]

    sowie

    \[\neg \operatorname{occurs-at-hour}_{e,h} \vee \neg \operatorname{occurs-at-room}_{e,r} \vee \operatorname{occurs-at-room-at-hour}_{e,r,h} \text{ .}\]
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn occurs-at-room-at-hour-occurs-at-room-relations
        [{:keys [events buildings num-days hours-per-day]}]
        (for [[event _] (events-to-schedule events)
              [building rooms] buildings
              [room _] rooms
              day (range num-days)
              hour (range hours-per-day)
              clause [(implies (occurs-at-room-at-hour event [building room] [day hour])
                               (occurs-at-hour event [day hour]))
                      (implies (occurs-at-room-at-hour event [building room] [day hour])
                               (occurs-at-room event [building room]))
                      #{(negate (occurs-at-hour event [day hour]))
                        (negate (occurs-at-room event [building room]))
                        (occurs-at-room-at-hour event [building room] [day hour])}]]
          clause))
    #+end_src

    Mit dieser Hilfsvariable ist die hier benutzte Bedingung zum
    Verhindern von Doppelbelegungen von Räumen

    \[\forall r \in \operatorname{Rooms}, h \in \operatorname{Hours } \operatorname{at-most}(\{\operatorname{occurs-at-room-at-hour}_{e,r,h} | e\in \operatorname{Events} \},1) \text{ .}\]
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn scheduled-room-clash-constraints
        [{:keys [buildings events num-days hours-per-day]}]
        (let [events (for [[event _] (events-to-schedule events)] event)]
          (for [[building rooms] buildings
                [room _] rooms
                day (range num-days)
                hour (range hours-per-day)
                clause (at-most (map #(occurs-at-room-at-hour
                                       % [building room] [day hour])
                                     events) 1)]
            clause)))
    #+end_src

*** Beachten von Zeitbeschränkungen
    Auch die vorgestellte Bedingung zum Beachten
    von Sperrzeiten gewisser Räume muss angepasst werden. Auch hier
    kann nun $\operatorname{occurs-at-room-at-hour}$ genutzt werden:

    \[\forall r \in \operatorname{Rooms}, \forall t \in \operatorname{times-not-available}(r) \bigwedge_{e \in \operatorname{Events}} \neg \operatorname{occurs-at-room-at-hour}_{e,r,h}\]

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn scheduled-rooms-not-available-constraints
        [{:keys [events buildings num-days hours-per-day]}]
        (for [[event _] (events-to-schedule events)
              [building rooms] buildings
              [room details] rooms
              :let [times-not-available (:times-not-available details)]
              time times-not-available]
          #{(negate (occurs-at-room-at-hour event [building room] time))}))
    #+end_src

*** Beachten von Wechselzeiten zwischen Gebäuden
    Analog zur Anpassung der Bedingung für Sperrzeiten, kann auch die
    Bedingung zum Beachten der Wegzeiten zwischen Gebäuden auf die
    Situation, in der auch die Räume verplant werden, erweitert
    werden:

    Für jedes Paar von Gebäuden $(b_1,b_2)$ mit
    $\operatorname{distance}(b_1,b_2) = d > 0$ und alle Paare $(e_{1},e_2)$ von Events, wobei
    \(\operatorname{resources}(e_1) \cap \operatorname{resources}(e_2)
    \neq \emptyset \) und jede Zeit $h$ wird gefordert, dass wenn
    $e_{1}$ zur Zeit $h$ in einem Raum $r_1$ von $b_1$ stattfindet,
    $e_2$ nicht zu einer nachfolgenden Stunde in einem Raum $r_2$ von
    $b_2$ stattfinden darf, welche weniger als $d$ von $h$ entfernt ist.
    Der Operator $\operatorname{next-times(h,d)}$ bezeichne diese Stunden.

    Explizit lautet diese Bedingung

    \begin{align}
    \label{eq:laaang}
    &\forall (b_1,b_2,d) \in \{(b_1,b_2,d) | (b_1,b_2) \in B \times B, d = \operatorname{distance}(b_1,b_2) > 0\} \text{,}\nonumber \\
    &(e_1,e_2) \in \{(e_1, e_2) | e_1 \in E, e_2 \in E, \operatorname{resources}(e_1) \cap \operatorname{resources}(e_2) \neq \emptyset \} \text{, }h \in \operatorname{Hours}  \nonumber \\
    &\operatorname{occurs-at-room-at-hour}_{e,r,h} \Rightarrow \bigwedge_{h'  \in \operatorname{next-times}(h,d)} \neg \operatorname{occurs-at-room-at-hour}_{e_2,r_2,h'} \text{ .}
    \end{align}

    Diese führt auf entsprechende Klauseln der Form

    \[\neg \operatorname{occurs-at-room-at-hour}_{e,r,h} \vee \neg \operatorname{occurs-at-room-at-hour}_{e_2,r_2,h'} \text{ .}\]

    Allerdings werden auf diese weise sehr viele Klauseln erzeugt, bei
    dem für diese Situation angepasstem größerem Beispielproblem sind
    es 10697400.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn room-distances-constraints
        [{:keys [events buildings num-days hours-per-day distances]}]
        (let [to-schedule (events-to-schedule events)]
          (for [[event {:keys [classes teachers]}] to-schedule
                :let [events-with-common-resource
                      (for [[e {cls :classes tchs :teachers}] to-schedule
                            :when (and (not= event e)
                                       (or (some classes cls) (some teachers tchs)))] e)]
                [building-1 rooms-1] buildings
                :let [buildings-in-distance
                      (for [[b rs] buildings
                            :let [distance (get distances [building-1 b] 0)]
                            :when (and (not= b building-1)
                                       (> distance 0))]
                        [b rs distance])]
                [building-2 rooms-2 dist] buildings-in-distance
                [room-1 _] rooms-1
                [room-2 _] rooms-2
                day (range num-days)
                hour (range hours-per-day)
                [nd nh] (next-times-at-day [day hour ] hours-per-day dist)
                event-2 events-with-common-resource]
            (implies (occurs-at-room-at-hour event [building-1 room-1] [day hour])
                     (negate (occurs-at-room-at-hour event-2 [building-2 room-2] [nd nh]))))))
    #+end_src

    Es ist möglich, mit den $\operatorname{class-in-building}$
    Variablen diese Bedingung effizienter zu kodieren. Dafür müssen
    diese aber zuerst für diese Situation angepasst werden.

    Die logische Äquivalenz von class-in-building ist die Folgende:
    \begin{align}
    \label{eq:cibwiederholt}
    &\forall c \in \operatorname{Classes}, h \in \operatorname{Times}, b \in \operatorname{Buildings} \nonumber \\
    &\operatorname{class-in-building}_{c,h,b} \Leftrightarrow \nonumber \\&
    \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), b = \operatorname{building}(e)} \operatorname{occurs-at-hour}_{e,h} \nonumber \\
 &\vee h \neq \operatorname{first-hour}(\operatorname{day}(h)) \wedge \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b}
    \end{align}

    Da nun die Bedingung $b = \operatorname{building}(e)$ nicht mehr
    gestellt werden kann, wird sie ersetzt durch  $\operatorname{occurs-at-room-at-hour}$ Variablen:


    \begin{align}
    \label{eq:neu}
    &\forall c \in \operatorname{Classes}, h \in \operatorname{Times}, b \in \operatorname{Buildings} \nonumber \\
    &\operatorname{class-in-building}_{c,h,b} \nonumber \\ &\Leftrightarrow  \bigvee_{e \in \operatorname{Events},c \in \operatorname{classes}(e), r \in \operatorname{rooms}(b)} \operatorname{occurs-at-room-at-hour}_{e,r,h} \\
     &\vee h \neq \operatorname{first-hour}(\operatorname{day}(h)) \wedge \neg \operatorname{teached-at}_{c,h} \wedge \operatorname{class-in-building}_{c,h-1,b}
    \end{align}

    Die Bedingungen für die $\operatorname{teacher-in-building}$
    Variablen werden genauso angepasst. Analog wie im Abschnitt
    [[ref:obiger-abschnitt]] werden aus diesen Formeln die entsprechenden
    Klauseln in konjunktiver Normalform generiert.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn scheduled-rooms-class-in-buildings-relations
        [{:keys [events buildings num-days hours-per-day classes]}]
        (concat
         (for [[event {:keys [classes]}] (events-to-schedule events)
               class classes
               [building rooms] buildings
               [room _] rooms
               day (range num-days)
               hour (range hours-per-day)]
           (implies (occurs-at-room-at-hour event [building room] [day hour])
                    (class-in-building class [day hour] building)))
         (for [[class _] classes
               :let [events
                     (for [[event {classes :classes}] (events-to-schedule events)
                           :when (classes class)]
                       event)]
               [building rooms] buildings
               day (range num-days)
               hour (range hours-per-day)
               :let [event-occurrences-in-building
                     (for [[room _] rooms
                           event events]
                       (occurs-at-room-at-hour event [building room] [day hour]))]
               clause (if (> hour 0)
                        [#{(negate (class-in-building class [day (dec hour)] building))
                           (teached-at class [day hour])
                           (class-in-building class [day hour] building)}
                         (implies (class-in-building class [day hour] building)
                                  (into #{} (concat event-occurrences-in-building
                                                    [(class-in-building class [day (dec hour)]
                                                                        building)])))
                         (implies (class-in-building class [day hour] building)
                                  (into #{} (concat event-occurrences-in-building
                                                    [(negate (teached-at class [day hour]))])))]
                        [(implies (class-in-building class [day hour] building)
                                  (into #{} event-occurrences-in-building))])]
           clause)))
              #+end_src

    
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn scheduled-rooms-teacher-in-buildings-relations
        [{:keys [events buildings num-days hours-per-day teachers]}]
        (concat
         (for [[event {:keys [teachers]}] (events-to-schedule events)
               teacher teachers
               [building rooms] buildings
               [room _] rooms
               day (range num-days)
               hour (range hours-per-day)]
           (implies (occurs-at-room-at-hour event [building room] [day hour])
                    (teacher-in-building teacher [day hour] building)))
         (for [[teacher _] teachers
               :let [events
                     (for [[event {teachers :teachers}] (events-to-schedule events)
                           :when (teachers teacher)]
                       event)]
               [building rooms] buildings
               day (range num-days)
               hour (range hours-per-day)
               :let [event-occurrences-in-building
                     (for [[room _] rooms
                           event events]
                       (occurs-at-room-at-hour event [building room] [day hour]))]
               clause (if (> hour 0)
                        [#{(negate (teacher-in-building teacher [day (dec hour)] building))
                           (teaches-at teacher [day hour])
                           (teacher-in-building teacher [day hour] building)}
                         (implies (teacher-in-building teacher [day hour] building)
                                  (into #{} (concat event-occurrences-in-building
                                                    [(teacher-in-building teacher [day (dec hour)]
                                                                          building)])))
                         (implies (teacher-in-building teacher [day hour] building)
                                  (into #{} (concat event-occurrences-in-building
                                                    [(negate (teaches-at teacher [day hour]))])))]
                        [(implies (teacher-in-building teacher [day hour] building)
                                  (into #{} event-occurrences-in-building))])]
           clause)))

              #+end_src

    Mit den angepassten Variablen lautet die Bedingung zum Beachten
    von Wechselzeiten für Klassen

    \begin{align}
    &\forall c \in \operatorname{Classes}, b \in \operatorname{Buildings}, h \in \operatorname{Hours} \\
& (\operatorname{class-in-building}_{c,h} \wedge \operatorname{teach
ed-at}_{c,h}) \Rightarrow \nonumber \\ &\bigwedge_{e_2 \in \operatorname{with-common-resource}, h_2 \in \operatorname{next-times(h,d)} }
\text{ .}
 \end{align}

    Dieses führt zu den Klauseln

    \[\neg \operatorname{class-in-building}_{c,r,h} \vee \neg \operatorname{teached-at}_{c,h} \vee \neg \operatorname{class-in-building}_{c,h_2,b_2} \text{ .}  \]

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn building-changes-constraints-for-classes
        [{:keys [events buildings num-days hours-per-day distances classes]}]
        (for [[class _] classes
              [building-1 rooms-1] buildings
              [building-2 rooms-2] buildings
              :let [distance (get distances [building-1 building-2] 0)]
              :when (and (not= building-1 building-2) (> distance 0))
              day (range num-days)
              hour (range hours-per-day)
              [nd nh] (next-times-at-day [day hour] hours-per-day distance)]
          #{(negate (class-in-building class [day hour] building-1))
            (negate (teached-at class [day hour]))
            (negate (class-in-building class [nd nh] building-2))}))
    #+end_src
    Analog ergibt sich
    \begin{align}
    &\forall t \in \operatorname{Teachers}, b \in \operatorname{Buildings}, h \in \operatorname{Hours} \\
& (\operatorname{teacher-in-building}_{t,h} \wedge \operatorname{teach
es-at}_{t,h}) \Rightarrow \nonumber \\ & \bigwedge_{e_2 \in \operatorname{with-common-resource}, h_2 \in \operatorname{next-times(h,d)}} \neg \operatorname{teacher-in-building}_{t
,h_2,b_2}
    \end{align}
    als Bedingung für die Lehrer, sowie die entsprechenden Klauseln

    \[\neg \operatorname{teacher-in-building}_{t,r,h} \vee \neg \operatorname{teached-at}_{t,h} \vee \neg \operatorname{teacher-in-building}_{t,h_2,b_2}  \text{ .} \]

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn building-changes-constraints-for-teachers
        [{:keys [events buildings num-days hours-per-day distances teachers]}]
        (for [[teacher _] teachers
              [building-1 rooms-1] buildings
              [building-2 rooms-2] buildings
              :let [distance (get distances [building-1 building-2] 0)]
              :when (and (not= building-1 building-2) (> distance 0))
              day (range num-days)
              hour (range hours-per-day)
              [nd nh] (next-times-at-day [day hour] hours-per-day distance)]
          #{(negate (teacher-in-building teacher [day hour] building-1))
            (negate (teaches-at teacher [day hour]))
            (negate (teacher-in-building teacher [nd nh] building-2))}))

    #+end_src

    Durch diese Verbesserung der Kodierung werden für das
    Beispielproblem nur noch 3750 Klauseln gebraucht, um
    sicherzustellen, dass sowohl Lehrer, als auch Klassen die
    Wegzeiten zwischen Gebäuden beachten.
*** Ergebnisse

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def room-scheduling-constraint-functions
        [#'occurs-at-day-occurs-at-hour-relations
         #'occurs-at-hour-teached-at-relations
         #'class-clash-constraints
         #'teacher-clash-constraints
         #'everything-scheduled-constraints
         #'predetermined-room-constraints
         #'predetermined-times-constraints
         #'forbidden-rooms-constraints
         #'scheduled-rooms-not-available-constraints
         #'starts-at-hour-occurs-at-hour-relations
         #'illegal-starting-times-constraints
         #'occurs-at-hour-teaches-at-relations
         #'occurs-at-room-at-hour-occurs-at-room-relations
         #'everything-exactly-one-room-constraints
         #'scheduled-room-clash-constraints
         #'scheduled-rooms-class-in-buildings-relations
         #'scheduled-rooms-teacher-in-buildings-relations
         #'building-changes-constraints-for-classes
         #'building-changes-constraints-for-teachers])


      (defn solve-problem-with-room-scheduling [entities]
        (solve-problem entities
                       {:constraint-functions room-scheduling-constraint-functions
                        :maxsat? false}))
    #+end_src


    Das Verplanen von Räumen wird ebenfalls an einem kleinen Beispiel illustriert:
    - Eine Klasse.
    - Ein Lehrer.
    - Ein Gebäude mit zwei Räumen
    - 2 Stunden Mathe für Klasse 1 unterrichtet von Lehrer 1 in beliebigen Räumen
    - 1 Tag mit 2 Stunden
    - Raum 1 ist in der ersten Stune, Raum 2 in der zweiten Stunde nicht verfügbar.

      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (def room-scheuling-example
          {:classes {:class-1 {}}
           :teachers {:teacher-1 {}}
           :buildings {:building-1 {:room-1 {:times-not-available #{[0 0]}}
                                    :room-2 {:times-not-available #{[0 1]}}}}
           :num-days 1
           :hours-per-day 2
           :events
           {
            :class-1-math
            (create-event :classes :class-1 :teachers #{:teacher-1} :number-of-times 2)}})
      #+end_src

    Der für dieses Problem erzeugte Stundenplan der Klasse 1 ist in
    Abbildung [[ref:fig:room-scheduling-example]] dargestellt. Da nun auch
    die Raumplanung wichtig ist, wird außerdem der Raum im Stundenplan
    durch $[\operatorname{building-name} \operatorname{room-name}]$ angezeigt.
    Man sieht, dass korrekterweise die erste Mathestunde auf Raum 2
    und die zweite auf Raum 1 gelegt wurde.

    #+CAPTION: Korrekte Raumplanung für das Beispielproblem.
    #+LABEL: fig:room-scheduling-example
    #+ATTR_LaTeX: :width 200px
[[/home/kima/programming/timetabling/images/bigger-example-entities-hard-problem-no-optimisation-example.png]]

    Beim größeren Beispielproblem werden mit den Außnahmen, dass Sport,
    Werken und Kunst weiterhin in ihren Räumen stattfinden müssen,
    alle festgelegten Raumzuordnungen fallen gelassen. Allerdings wird
    dabei gefordert, dass alle anderen Unterrichtsfächer /nicht/ in
    den Funktionsräumen Sporthalle, Werkraum und Kunstraum
    stattfinden. Dabei wurde eine Formel mit 1327008 Klauseln dem
    verwendeten Solver übergeben.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def bigger-example-room-schedule-entities
        (merge (select-keys bigger-example-entities
                            [:classes :teachers :buildings :distances
                             :num-days :hours-per-day])
               {:events
                {:class-1-math
                 (create-event :classes :class-1  :teachers #{:teacher-1} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}) ;;hier auf 30 ändern
                 :class-2-math
                 (create-event :classes :class-2  :teachers #{:teacher-2} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-3-math
                 (create-event :classes :class-3  :teachers #{:teacher-3} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}) ;;hier auf 30 ändern
                 :class-4-math
                 (create-event :classes :class-4  :teachers #{:teacher-4} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-5-math
                 (create-event :classes :class-5  :teachers #{:teacher-5} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}) ;;hier auf 30 ändern
                 :class-6-math
                 (create-event :classes :class-6  :teachers #{:teacher-6} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}):class-7-math
                 (create-event :classes :class-7  :teachers #{:teacher-7} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}) ;;hier auf 30 ändern
                 :class-8-math
                 (create-event :classes :class-8  :teachers #{:teacher-8} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-9-math
                 (create-event :classes :class-9  :teachers #{:teacher-9} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}) ;;hier auf 30 ändern
                 :class-10-math
                 (create-event :classes :class-10  :teachers #{:teacher-10} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}):class-11-math
                 (create-event :classes :class-11  :teachers #{:teacher-11} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]}) ;;hier auf 30 ändern
                 :class-12-math
                 (create-event :classes :class-12  :teachers #{:teacher-12} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-1-sk
                 (create-event :classes :class-1  :teachers #{:teacher-1} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-2-sk
                 (create-event :classes :class-2  :teachers #{:teacher-2} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-3-sk
                 (create-event :classes :class-3  :teachers #{:teacher-3} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-4-sk
                 (create-event :classes :class-4  :teachers #{:teacher-4} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-5-sk
                 (create-event :classes :class-5  :teachers #{:teacher-5} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]} )
                 :class-6-sk
                 (create-event :classes :class-6  :teachers #{:teacher-6} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-7-sk
                 (create-event :classes :class-7  :teachers #{:teacher-7} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-8-sk
                 (create-event :classes :class-8  :teachers #{:teacher-8} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-9-sk
                 (create-event :classes :class-9  :teachers #{:teacher-9} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-10-sk
                 (create-event :classes :class-10  :teachers #{:teacher-10} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-11-sk
                 (create-event :classes :class-11  :teachers #{:teacher-11} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-12-sk
                 (create-event :classes :class-12  :teachers #{:teacher-12} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-1-german
                 (create-event :classes :class-1  :teachers #{:teacher-1} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-2-german
                 (create-event :classes :class-2  :teachers #{:teacher-2} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-3-german
                 (create-event :classes :class-3  :teachers #{:teacher-3} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-4-german
                 (create-event :classes :class-4  :teachers #{:teacher-4} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-5-german
                 (create-event :classes :class-5  :teachers #{:teacher-5} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-6-german
                 (create-event :classes :class-6  :teachers #{:teacher-6} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-7-german
                 (create-event :classes :class-7  :teachers #{:teacher-7} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-8-german
                 (create-event :classes :class-8  :teachers #{:teacher-8} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-9-german
                 (create-event :classes :class-9  :teachers #{:teacher-9} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-10-german
                 (create-event :classes :class-10  :teachers #{:teacher-10} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-11-german
                 (create-event :classes :class-11  :teachers #{:teacher-11} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-12-german
                 (create-event :classes :class-12  :teachers #{:teacher-12} :number-of-times 4 :forbidden-rooms #{[:building-2 :werkraum] [:building-1 :art-room] [:sporthalle :sporthalle]})
                 :class-1-sport
                 (create-event :classes :class-1 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1 )
                 :class-2-sport
                 (create-event :classes :class-2 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-3-sport
                 (create-event :classes :class-3 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-4-sport
                 (create-event :classes :class-4 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-5-sport
                 (create-event :classes :class-5 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-6-sport
                 (create-event :classes :class-6 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-7-sport
                 (create-event :classes :class-7 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-8-sport
                 (create-event :classes :class-8 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-9-sport
                 (create-event :classes :class-9 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-10-sport
                 (create-event :classes :class-10 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-11-sport
                 (create-event :classes :class-11 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-12-sport
                 (create-event :classes :class-12 :rooms #{[:sporthalle :sporthalle]} :teachers #{:sportlehrer} :durations [2] :number-of-times 1)
                 :class-1-art
                 (create-event :classes :class-1 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-1} :number-of-times 2)
                 :class-2-art
                 (create-event :classes :class-2 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-2} :number-of-times 2)
                 :class-3-art
                 (create-event :classes :class-3 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-3} :number-of-times 2)
                 :class-4-art
                 (create-event :classes :class-4 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-4} :number-of-times 2)
                 :class-5-art
                 (create-event :classes :class-5 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-5} :number-of-times 2)
                 :class-6-art
                 (create-event :classes :class-6 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-6} :number-of-times 2)
                 :class-7-art
                 (create-event :classes :class-7 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-7} :number-of-times 2)
                 :class-8-art
                 (create-event :classes :class-8 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-8} :number-of-times 2)
                 :class-9-art
                 (create-event :classes :class-9 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-9} :number-of-times 2)
                 :class-10-art
                 (create-event :classes :class-10 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-10} :number-of-times 2)
                 :class-11-art
                 (create-event :classes :class-11 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-11} :number-of-times 2)
                 :class-12-art
                 (create-event :classes :class-12 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-12} :number-of-times 2)
                 :class-1-werken
                 (create-event :classes :class-1 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-1} :number-of-times 2)
                 :class-2-werken
                 (create-event :classes :class-2 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-2} :number-of-times 2)
                 :class-3-werken
                 (create-event :classes :class-3 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-3} :number-of-times 2)
                 :class-4-werken
                 (create-event :classes :class-4 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-4} :number-of-times 2)
                 :class-5-werken
                 (create-event :classes :class-5 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-5} :number-of-times 2)
                 :class-6-werken
                 (create-event :classes :class-6 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-6} :number-of-times 2)
                 :class-7-werken
                 (create-event :classes :class-7 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-7} :number-of-times 2)
                 :class-8-werken
                 (create-event :classes :class-8 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-8} :number-of-times 2)
                 :class-9-werken
                 (create-event :classes :class-9 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-9} :number-of-times 2)
                 :class-10-werken
                 (create-event :classes :class-10 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-10} :number-of-times 2)
                 :class-11-werken
                 (create-event :classes :class-11 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-11} :number-of-times 2)
                 :class-12-werken
                 (create-event :classes :class-12 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-12} :number-of-times 2)}}))
    #+end_src
    Dieses Problem wurde von dem hier entwickelten Programm in 43 Sekunden gelöst.
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def example-result
        {:events {:class-9-werken {:classes #{:class-9}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-9} #{:teacher-9}], :durations [1 1], :forbidden-rooms #{}, :times [[2 5] [1 2]]}, :class-2-werken {:classes #{:class-2}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :forbidden-rooms #{}, :times [[2 3] [3 0]]}, :class-10-sport {:classes #{:class-10}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[2 4]]}, :class-5-art {:classes #{:class-5}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-5} #{:teacher-5}], :durations [1 1], :forbidden-rooms #{}, :times [[0 3] [3 1]]}, :class-3-german {:classes #{:class-3}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-6]} #{[:building-2 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 1] [3 3] [4 1] [0 4]]}, :class-7-werken {:classes #{:class-7}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-7} #{:teacher-7}], :durations [1 1], :forbidden-rooms #{}, :times [[4 3] [4 2]]}, :class-3-math {:classes #{:class-3}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-1]} #{[:building-2 :room-2]} #{[:building-2 :room-1]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 0] [4 3] [4 2] [0 2]]}, :class-2-art {:classes #{:class-2}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :forbidden-rooms #{}, :times [[3 4] [0 1]]}, :class-3-werken {:classes #{:class-3}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-3} #{:teacher-3}], :durations [1 1], :forbidden-rooms #{}, :times [[1 4] [3 1]]}, :class-1-sk {:classes #{:class-1}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-1 :room-1]} #{[:building-2 :room-6]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 0] [2 1] [0 4] [2 4]]}, :class-8-math {:classes #{:class-8}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-1 :room-6]} #{[:building-2 :room-6]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 4] [2 3] [4 1] [4 5]]}, :class-1-art {:classes #{:class-1}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :forbidden-rooms #{}, :times [[4 3] [2 0]]}, :class-6-werken {:classes #{:class-6}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-6} #{:teacher-6}], :durations [1 1], :forbidden-rooms #{}, :times [[2 2] [3 5]]}, :class-10-art {:classes #{:class-10}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-10} #{:teacher-10}], :durations [1 1], :forbidden-rooms #{}, :times [[4 4] [3 5]]}, :class-9-sport {:classes #{:class-9}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[3 2]]}, :class-12-art {:classes #{:class-12}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-12} #{:teacher-12}], :durations [1 1], :forbidden-rooms #{}, :times [[2 1] [1 2]]}, :class-1-sport {:classes #{:class-1}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[3 0]]}, :class-9-art {:classes #{:class-9}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-9} #{:teacher-9}], :durations [1 1], :forbidden-rooms #{}, :times [[2 2] [4 0]]}, :class-10-werken {:classes #{:class-10}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-10} #{:teacher-10}], :durations [1 1], :forbidden-rooms #{}, :times [[1 5] [1 0]]}, :class-8-sport {:classes #{:class-8}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[0 2]]}, :class-3-sk {:classes #{:class-3}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-1]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 5] [1 1] [3 0] [4 5]]}, :class-11-werken {:classes #{:class-11}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-11} #{:teacher-11}], :durations [1 1], :forbidden-rooms #{}, :times [[4 1] [4 4]]}, :class-7-math {:classes #{:class-7}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-1 :room-6]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 1] [2 3] [2 2] [1 0]]}, :class-8-art {:classes #{:class-8}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-8} #{:teacher-8}], :durations [1 1], :forbidden-rooms #{}, :times [[4 2] [0 5]]}, :class-4-art {:classes #{:class-4}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-4} #{:teacher-4}], :durations [1 1], :forbidden-rooms #{}, :times [[1 4] [2 5]]}, :class-7-german {:classes #{:class-7}, :rooms [#{[:building-1 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-6]} #{[:building-1 :room-6]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 5] [2 0] [3 1] [0 1]]}, :class-6-sport {:classes #{:class-6}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[4 4]]}, :class-11-sport {:classes #{:class-11}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[3 4]]}, :class-2-german {:classes #{:class-2}, :rooms [#{[:building-2 :room-3]} #{[:building-1 :room-1]} #{[:building-2 :room-4]} #{[:building-1 :room-4]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 3] [0 0] [4 3] [4 0]]}, :class-7-art {:classes #{:class-7}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-7} #{:teacher-7}], :durations [1 1], :forbidden-rooms #{}, :times [[1 5] [4 5]]}, :class-4-math {:classes #{:class-4}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-2]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 0] [0 3] [0 0] [0 5]]}, :class-6-german {:classes #{:class-6}, :rooms [#{[:building-2 :room-5]} #{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-2]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 5] [3 2] [1 2] [3 1]]}, :class-4-german {:classes #{:class-4}, :rooms [#{[:building-2 :room-3]} #{[:building-2 :room-5]} #{[:building-2 :room-1]} #{[:building-2 :room-6]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 3] [0 4] [2 3] [3 2]]}, :class-1-german {:classes #{:class-1}, :rooms [#{[:building-2 :room-1]} #{[:building-1 :room-6]} #{[:building-2 :room-5]} #{[:building-2 :room-4]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 3] [4 2] [4 5] [1 5]]}, :class-11-math {:classes #{:class-11}, :rooms [#{[:building-2 :room-6]} #{[:building-1 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-1]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 4] [1 3] [0 2] [3 1]]}, :class-11-art {:classes #{:class-11}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-11} #{:teacher-11}], :durations [1 1], :forbidden-rooms #{}, :times [[2 3] [1 1]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-2]} #{[:building-1 :room-1]} #{[:building-2 :room-2]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 2] [0 3] [1 5] [2 2]]}, :class-12-werken {:classes #{:class-12}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-12} #{:teacher-12}], :durations [1 1], :forbidden-rooms #{}, :times [[4 0] [3 3]]}, :class-6-sk {:classes #{:class-6}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-5]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 4] [2 0] [4 2] [2 4]]}, :class-4-sport {:classes #{:class-4}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[4 0]]}, :class-11-sk {:classes #{:class-11}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-1]} #{[:building-2 :room-6]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 5] [2 5] [4 0] [3 0]]}, :class-2-sport {:classes #{:class-2}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[1 0]]}, :class-2-sk {:classes #{:class-2}, :rooms [#{[:building-1 :room-5]} #{[:building-2 :room-1]} #{[:building-2 :room-6]} #{[:building-2 :room-1]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 2] [2 5] [4 4] [0 5]]}, :class-8-werken {:classes #{:class-8}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-8} #{:teacher-8}], :durations [1 1], :forbidden-rooms #{}, :times [[3 2] [2 1]]}, :class-5-werken {:classes #{:class-5}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-5} #{:teacher-5}], :durations [1 1], :forbidden-rooms #{}, :times [[1 3] [3 4]]}, :class-12-sk {:classes #{:class-12}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-3]} #{[:building-1 :room-5]} #{[:building-1 :room-2]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 4] [3 5] [0 4] [2 5]]}, :class-3-sport {:classes #{:class-3}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[2 0]]}, :class-7-sport {:classes #{:class-7}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[0 4]]}, :class-12-math {:classes #{:class-12}, :rooms [#{[:building-1 :room-6]} #{[:building-2 :room-6]} #{[:building-1 :room-6]} #{[:building-2 :room-2]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 5] [4 1] [0 3] [4 3]]}, :class-4-werken {:classes #{:class-4}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-4} #{:teacher-4}], :durations [1 1], :forbidden-rooms #{}, :times [[0 2] [2 0]]}, :class-10-math {:classes #{:class-10}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-2 :room-4]} #{[:building-1 :room-6]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 2] [2 1] [1 4] [3 4]]}, :class-5-sk {:classes #{:class-5}, :rooms [#{[:building-2 :room-5]} #{[:building-2 :room-2]} #{[:building-2 :room-6]} #{[:building-2 :room-2]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 0] [1 4] [2 1] [3 3]]}, :class-9-german {:classes #{:class-9}, :rooms [#{[:building-2 :room-1]} #{[:building-1 :room-1]} #{[:building-1 :room-1]} #{[:building-2 :room-6]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 5] [4 1] [0 1] [2 0]]}, :class-3-art {:classes #{:class-3}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-3} #{:teacher-3}], :durations [1 1], :forbidden-rooms #{}, :times [[2 4] [1 0]]}, :class-9-sk {:classes #{:class-9}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-1 :room-3]} #{[:building-2 :room-1]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 4] [1 1] [0 3] [1 5]]}, :class-11-german {:classes #{:class-11}, :rooms [#{[:building-1 :room-6]} #{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 2] [2 0] [3 2] [4 2]]}, :class-4-sk {:classes #{:class-4}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-2 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 2] [3 5] [3 3] [4 4]]}, :class-5-sport {:classes #{:class-5}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[0 0]]}, :class-6-art {:classes #{:class-6}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-6} #{:teacher-6}], :durations [1 1], :forbidden-rooms #{}, :times [[0 0] [0 4]]}, :class-9-math {:classes #{:class-9}, :rooms [#{[:building-2 :room-5]} #{[:building-1 :room-6]} #{[:building-1 :room-6]} #{[:building-2 :room-1]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 3] [0 0] [2 3] [3 0]]}, :class-8-german {:classes #{:class-8}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-4]} #{[:building-2 :room-1]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 0] [1 2] [4 4] [2 4]]}, :class-1-werken {:classes #{:class-1}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :forbidden-rooms #{}, :times [[0 1] [1 1]]}, :class-5-math {:classes #{:class-5}, :rooms [#{[:building-1 :room-2]} #{[:building-1 :room-6]} #{[:building-2 :room-6]} #{[:building-1 :room-6]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 0] [1 1] [2 2] [0 4]]}, :class-10-german {:classes #{:class-10}, :rooms [#{[:building-1 :room-4]} #{[:building-2 :room-5]} #{[:building-1 :room-1]} #{[:building-1 :room-5]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 2] [3 2] [0 2] [4 0]]}, :class-7-sk {:classes #{:class-7}, :rooms [#{[:building-2 :room-4]} #{[:building-2 :room-4]} #{[:building-1 :room-2]} #{[:building-2 :room-4]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 5] [3 3] [0 0] [3 2]]}, :class-1-math {:classes #{:class-1}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-4]} #{[:building-1 :room-4]} #{[:building-1 :room-5]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 2] [1 0] [2 2] [0 3]]}, :class-12-german {:classes #{:class-12}, :rooms [#{[:building-1 :room-3]} #{[:building-2 :room-2]} #{[:building-2 :room-3]} #{[:building-1 :room-5]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 2] [0 0] [4 2] [1 1]]}, :class-6-math {:classes #{:class-6}, :rooms [#{[:building-1 :room-1]} #{[:building-2 :room-2]} #{[:building-2 :room-2]} #{[:building-2 :room-1]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 1] [4 0] [0 2] [2 1]]}, :class-5-german {:classes #{:class-5}, :rooms [#{[:building-1 :room-6]} #{[:building-2 :room-5]} #{[:building-2 :room-6]} #{[:building-2 :room-4]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 4] [4 1] [3 5] [4 2]]}, :class-8-sk {:classes #{:class-8}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-6]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 1] [2 2] [1 4] [1 3]]}, :class-12-sport {:classes #{:class-12}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[1 4]]}, :class-10-sk {:classes #{:class-10}, :rooms [#{[:building-1 :room-2]} #{[:building-1 :room-3]} #{[:building-1 :room-5]} #{[:building-1 :room-2]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 3] [1 2] [0 0] [2 0]]}}, :hours-per-day 6, :num-days 5, :distances {[:building-1 :sporthalle] 1, [:sporthalle :building-2] 1, [:sporthalle :building-1] 1, [:building-2 :sporthalle] 1, [:building-2 :building-1] 1, [:building-1 :building-2] 1}, :buildings {:building-1 {:room-1 {}, :room-2 {}, :room-3 {}, :room-4 {}, :room-5 {}, :room-6 {}, :art-room {}}, :building-2 {:room-1 {}, :room-2 {}, :room-3 {}, :room-4 {}, :room-5 {}, :room-6 {}, :werkraum {}}, :sporthalle {:sporthalle {}}}, :teachers {:teacher-7 {}, :teacher-6 {}, :teacher-10 {}, :teacher-1 {}, :teacher-11 {}, :sportlehrer {}, :teacher-4 {}, :teacher-2 {}, :teacher-12 {}, :teacher-8 {}, :teacher-3 {}, :teacher-5 {}, :teacher-9 {}}, :classes {:class-4 {:class-teacher :teacher-4, :class-room [:building-2 :room-2]}, :class-10 {:class-teacher :teacher-10, :class-room [:building-2 :room-5]}, :class-11 {:class-teacher :teacher-11, :class-room [:building-1 :room-6]}, :class-8 {:class-teacher :teacher-8, :class-room [:building-2 :room-4]}, :class-2 {:class-teacher :teacher-2, :class-room [:building-2 :room-1]}, :class-12 {:class-teacher :teacher-12, :class-room [:building-2 :room-6]}, :class-3 {:class-teacher :teacher-3, :class-room [:building-1 :room-2]}, :class-5 {:class-teacher :teacher-5, :class-room [:building-1 :room-3]}, :class-1 {:class-teacher :teacher-1, :class-room [:building-1 :room-1]}, :class-7 {:class-teacher :teacher-7, :class-room [:building-1 :room-4]}, :class-6 {:class-teacher :teacher-6, :class-room [:building-2 :room-3]}, :class-9 {:class-teacher :teacher-9, :class-room [:building-1 :room-5]}}})

    #+end_src

    Bei Betrachtung der entstandenen Raumverteilung fällt auf, dass
    manche Räume fast gänzlich verplant sind, dafür andere nur sehr
    wenige Veranstaltungen in ihrem Belegungsplan haben. Abbildungen
    [[ref:fig:full-room]] und [[ref:fig:not-full-room]] belegen dies.

    #+CAPTION: Fast gänzliche Auslastung in Raum 1 des 2. Gebäudes
    #+LABEL: fig:full-room
    #+ATTR_LaTeX: :width 400px
[[/home/kima/programming/timetabling/images/bigger-example-entities-hard-problem-no-optimisation-class-example-room.png]]

    #+CAPTION: Sehr geringe Auslastung vom Raum 3 des 2. Gebäudes
    #+LABEL: fig:not-full-room
    #+ATTR_LaTeX: :with 40px
[[/home/kima/programming/timetabling/images/bigger-example-entities-hard-problem-no-optimisation-class-example-room-2.png]]

  Auch das um die Raumplanung erweiterte Problem der Erzeugung eines
  zulässigen Stundenplans lässt sich mit dem hier gemachten Ansatz
  für ein Problem realistischer Größe noch effizient lösen. Im
  nächsten Abschnitt wird die Anpassung der Optimalitätsbedingungen
  für das erweiterte Problem beschrieben.

*** Untersuchung der Skalierbarkeit
    Um das skalierbare Problem an die Situation der Raumplanung
    anzupassen, werden alle Raumzuweisungen aufgehoben. Um das Problem
    zu lösen, muss so für jede Veranstaltung sowohl eine Zeit, also
    auch ein Raum ausgewählt werden und bei einer zulässigen Lösung
    sind sowohl alle Räume als auch alle Klassen und Lehrer zeitlich
    komplett ausgelastet.
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn create-scalable-room-scheduling-problem [num-hours num-days num-classes]
        (let [num-slots (* num-days num-hours)]
          {:classes (reduce #(assoc %1 (keyword (str "class-" %2))
                                    {:class-teacher (keyword (str "teacher-" %2))
                                     :class-room [(keyword (str "building-" %2)) :room-1]})
                            {} (range num-classes))
           :teachers (reduce #(assoc %1 (keyword (str "teacher-" %2)) {}) {} (range num-classes))
           :distances {}
           :num-days num-days
           :hours-per-day num-hours
           :buildings (reduce #(assoc %1 (keyword (str "building-" %2)) {:room-1 {}})
                              {} (range num-classes))
           :events (reduce #(assoc %1 (keyword (str "ef-" %2))
                                   (create-event :classes (keyword (str "class-" %2))
                                                 :teachers #{(keyword (str "teacher-" %2))}
                                                 :number-of-times num-slots))
                           {} (range num-classes))}))
    #+end_src

    #+CAPTION: Anzahl erzeugter Klauseln und Laufzeit des Solvers bei unterschiedlicher Klassenzahl
    #+NAME: tab:scalable-room-scheduling
    | Klassen | Klauseln | Laufzeit (s) des Solvers |
    |---------+----------+--------------------------|
    |       1 |    98720 |                      0,8 |
    |       2 |   224840 |                      2,5 |
    |       3 |   381405 |                      5,5 |
    |       4 |   562360 |                       12 |
    |       5 |   781775 |                     20,8 |
    |       6 |  1018860 |                     36,5 |
    |       7 |  1288735 |                     58,5 |
    |       8 |  1580480 |                     96,9 |
    |       9 |  1948275 |                    134,4 |
    |      10 |  2299300 |                    323,3 |
    |      11 |  2686475 |                    402,9 |
    |      12 |  3092160 |                    531,4 |

    An Tabelle [[ref:tab:scalable-room-scheduling]] ist zu sehen, dass das
    um Raumplanung erweiterte skalierbare Problem schon bei viel
    kleineren Problemgrößen erhebliche Zeit zur Lösung braucht. Der
    Versuch, das Problem für 20 Klassen zu lösen, wurde nach 21
    Stunden abgebrochen.

    Um mit dem hier vorgestellten Ansatz auch größere Probleme
    effizient behandeln zu können, bieten sich ein paar Ansätze zur
    Optimierung an:
    - Wie in [[cite:ttpsat]] könnte, zumindest für bestimmte
      Veranstaltungen, gefordert werden, dass alle $n$ Vorkommen einer
      Veranstaltung im gleichen Raum stattfinden. Dies würde
      ermöglichen, anstatt Klauseln für $n$ Events, nur noch Klauseln
      für ein Event zu erzeugen. Bei solch einem Event würde dann die
      Bedingung, dass es zu exakt einer Stunde stattfindet, durch die,
      dass es an exakt $n$ Stunden stattfindet, ersetzt werden.
    - Bei echten Problemem kommt es oft vor, dass eine Veranstaltung
      nur in wenigen Räumen abgehalten werden kann, zum Beispiel
      braucht der Musikunterricht einen der vorhandenen Musikräume in
      einem der Gebäude. Die Anzahl der dafür in Frage kommenden Räume
      ist aber im Vergleich zu den insgesamt vorhandenen Räumen sehr
      gering. Dies könnte in der angepassten Kodierung genutzt werden,
      zum Beispiel bei der Beachtung von Zeitbeschränkungen gewisser
      Räume. Die Klausel $\neg
      \operatorname{occurs-at-room-at-hour}_{e,r,h}$ müsste dabei
      nicht mehr für alle Events, sondern nur über die Events, bei
      denen der Raum $r$ in Frage kommt, gefordert werden.



    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn create-scalable-room-scheduling-problem-one-building [num-hours num-days num-classes]
        (let [num-slots (* num-days num-hours)]
          {:classes (reduce #(assoc %1 (keyword (str "class-" %2))
                                    {:class-teacher (keyword (str "teacher-" %2))
                                     :class-room [:b-1 (keyword (str "room-" %2))]})
                            {} (range num-classes))
           :teachers (reduce #(assoc %1 (keyword (str "teacher-" %2)) {}) {} (range num-classes))
           :distances {}
           :num-days num-days
           :hours-per-day num-hours
           :buildings (reduce #(assoc %1 (keyword (str "building-" %2)) {:room-1 {}})
                              {} (range num-classes))
           :events (reduce #(assoc %1 (keyword (str "ef-" %2))
                                   (create-event :classes (keyword (str "class-" %2))
                                                 :teachers #{(keyword (str "teacher-" %2))}
                                                 :number-of-times num-slots))
                           {} (range num-classes))}))
    #+end_src

    Wie in Abschnitt [[ref:skalierbarkeit-simple]] beschrieben, ist es
    möglich, die Anzahl von Räumen unabhängig von den anderen
    Eingabegrößen zu skalieren. In Tabelle [[ref:tab:moar-roomz]] wird die
    Laufzeit des Solvers, sowie die Anzahl an erzeugten Klauseln für
    das um 1 Gebäude mit 10 bis 100 Räumen erweiterte Beispielproblem
    angegeben. Selbst bei 100 zusätzlichen Räumen kann das Problem
    noch in ca. 1,5 Minuten gelöst werden. Durch alleiniges hinzufügen
    von Räumen wird dem Solver zwar durch die erhöhte Anzahl von
    Klauseln ein schwereres Problem geliefert, allerdings muss er
    immer noch die gleiche Anzahl an Entscheidungen treffen.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn bigger-example-room-scheduling-entities-more-rooms [roomcount]
        (-> bigger-example-room-schedule-entities
            (update-in [:buildings] assoc :new-building
                       (into {} (for [i (range roomcount)] [(keyword (str "room-" i)) {}])))
            (update-in [:distances]
                       (fn [distances]
                         (reduce #(assoc %1 %2 1)
                                 distances
                                 (for [b (:buildings bigger-example-room-schedule-entities)
                                       key [[b :new-building] [:new-building b]]]
                                   key))))))
    #+end_src

    #+CAPTION: Veränderung der Laufzeit des Solvers bei zusätzlichen Räumen
    #+NAME: tab:moar-roomz
    | Zusätzliche Räume | Anzahl Klauseln | Laufzeit (s) des Solvers |
    |-------------------+-----------------+--------------------------|
    |                10 |         2090384 |                       23 |
    |                20 |         2988848 |                     33.3 |
    |                30 |         3671888 |                     35.5 |
    |                40 |         4354928 |                       44 |
    |                50 |         5605904 |                       56 |
    |                60 |         6288944 |                     65.5 |
    |                70 |         6971984 |                     82.2 |
    |                80 |         7655024 |                     79.4 |
    |                90 |         8338064 |                     78.5 |
    |               100 |         9021104 |                       93 |


** Erzeugung eines optimalen Stundenplans

    Die oben beschriebenen Minimierungsbedingungen für Lücken zwischen
    Veranstaltungen für Klassen und für Lehrer brauchen keine
    Anpassung an die neue Situation, da sie die Beziehung
    $\operatorname{rooms}$ nicht verwenden.

    Auf diese Beziehung wird ebenso zur Minimierung der Gebäudewechsel
    nicht direkt zugegriffen, aber Indirekt durch die
    $\operatorname{class-in-building}$ Variablen. Da diese schon im
    letzten Abschnitt auf das erweiterte Problem angepasst wurden,
    können die beschriebenen Optimalitätsbedingungen /ohne Anpassung/
    für diese Situation wiederverwendet werden.

*** Optimal room scheduling constraints                            :noexport:
      #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (def optimal-constraints-for-room-scheduling
          [#'occurs-at-day-occurs-at-hour-relations
           #'occurs-at-hour-teached-at-relations
           #'class-clash-constraints
           #'teacher-clash-constraints
           #'everything-scheduled-constraints
           #'predetermined-room-constraints
           #'predetermined-times-constraints
           #'forbidden-rooms-constraints
           #'scheduled-rooms-not-available-constraints
           #'starts-at-hour-occurs-at-hour-relations
           #'illegal-starting-times-constraints
           #'occurs-at-hour-teaches-at-relations
           #'occurs-at-room-at-hour-occurs-at-room-relations
           #'everything-exactly-one-room-constraints
           #'scheduled-room-clash-constraints
           #'minimize-gaps-for-classes-constraints
           #'minimize-gaps-for-teachers-constraints
           #'scheduled-rooms-class-in-buildings-relations
           #'scheduled-rooms-teacher-in-buildings-relations
           #'minimize-building-changes-constraints-for-classes
           #'minimize-building-changes-constraints-for-teachers
           #'building-changes-constraints-for-classes
           #'building-changes-constraints-for-teachers])


        (defn solve-problem-optimally-with-room-scheduling [entities]
          (solve-problem entities {:constraint-functions optimal-constraints-for-room-scheduling :maxsat? true}))
              #+end_src

*** NEXT Neues Beispielprogramm                                    :noexport:
    :PROPERTIES:
    :ID:       2ce20f73-d77c-4ecd-88df-83a32a6b4db0
    :END:
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (def example-room-schedule-entities
        (merge (select-keys example-entities
                            [:classes :buildings :num-days :hours-per-day :teachers :distances])
               {:events
                {:class-1-math
                 (create-event :classes :class-1  :teachers #{:teacher-1} :number-of-times 4)
                 :class-2-math
                 (create-event :classes :class-2  :teachers #{:teacher-2} :number-of-times 4)
                 :class-1-sk
                 (create-event :classes :class-1  :teachers #{:teacher-1} :number-of-times 4)
                 :class-2-sk
                 (create-event :classes :class-2  :teachers #{:teacher-2} :number-of-times 4)
                 :class-1-german
                 (create-event :classes :class-1  :teachers #{:teacher-1} :number-of-times 4)
                 :class-2-german
                 (create-event :classes :class-2  :teachers #{:teacher-2} :number-of-times 4)
                 :class-1-sport
                 (create-event :classes :class-1 :rooms #{[:sporthalle :sporthalle]} :teachers #{:teacher-2} :durations [2] :number-of-times 1)
                 :class-2-sport
                 (create-event :classes :class-2 :rooms #{[:sporthalle :sporthalle]} :teachers #{:teacher-2} :durations [2] :number-of-times 1)
                 :class-1-art
                 (create-event :classes :class-1 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-1} :number-of-times 4)
                 :class-2-art
                 (create-event :classes :class-2 :rooms #{[:building-1 :art-room]} :teachers #{:teacher-1} :number-of-times 4)
                 :class-1-werken
                 (create-event :classes :class-1 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-1} :number-of-times 2)
                 :class-2-werken
                 (create-event :classes :class-2 :rooms #{[:building-2 :werkraum]} :teachers #{:teacher-1} :number-of-times 2) }}))
    #+end_src

*** Ergebnisse
    Um die optimale Verplanung von Räumen zu illustrieren, wird
    folgendes Beispiel betrachtet:
    - Zwei Klassen.
    - Zwei Lehrer.

    - Zwei Gebäude mit je einem Raum.
    - 2 Stunden Mathe für beide Klassen, Klasse 1 von Lehrer 1 und
      Klasse 2 von Lehrer 2 unterrichtet in beliebigen Räumen.
    - 1 Tag mit 3 Stunden.
    - Zwischen den beiden Gebäuden muss eine Stunde Wechselzeit freigelassen werden.

    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (def optimal-room-scheduling-example
          {
           :classes {:class-1 {}
                     :class-2 {}}
           :teachers {:teacher-1 {}}
           :buildings {:building-1 {:room-1 {}}
                       :building-2 {:room-1 {}}}
           :distances {[:building-1 :building-2] 1
                       [:building-2 :building-1] 1}
           :num-days 1
           :hours-per-day 3
           :events {
                    :class-1-math
                    (create-event :classes :class-1 :teachers #{:teacher-1} :number-of-times 2)
                    :class-2-math
                    (create-event :classes :class-2 :teachers #{:teacher-2} :number-of-times 2)}})
      #+end_src

    Ohne die Optimalitätsbedingungen wurde der in Abbildung
    [[ref:fig:without-optimisation-class-1]] und Abbildung
    [[ref:fig:without-optimisation-class-2]] dargestellte Stundenplan
    erzeugt.

    #+CAPTION: Stundenplan für Klasse 1 ohne Optimierung.
    #+LABEL: fig:without-optimisation-class-1
    #+ATTR_LaTeX: :width 200px
    [[/home/kima/programming/timetabling/images/hard-problem-with-optimisation-example-without-optimisation-class-1.png]]

    #+CAPTION: Stundenplan für Klasse 2 ohne Optimierung.
    #+LABEL: fig:without-optimisation-class-2
    #+ATTR_LaTeX: :width 200px
    [[/home/kima/programming/timetabling/images/hard-problem-with-optimisation-example-without-optimisation-class-2.png]]

   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (def example-ents-optimal-room-scheduling-without-optimisation
        {:classes {:class-1 {}, :class-2 {}}, :teachers {:teacher-1 {}}, :buildings {:building-1 {:room-1 {}}, :building-2 {:room-1 {}}}, :distances {[:building-2 :building-1] 1, [:building-1 :building-2] 1}, :num-days 1, :hours-per-day 3, :events {:class-1-math {:classes #{:class-1}, :rooms [#{[:building-2 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :forbidden-rooms #{}, :times [[0 2] [0 0]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :forbidden-rooms #{}, :times [[0 2] [0 1]]}}})
      #+end_src

   Dieser Stundenplan ist allerdings nicht optimal, da Klasse 1
   zwischen Gebäude 1 und 2 wechseln muss.

   Stellt man zusätzlich noch die Optimalitätsbedingungen als weiche
   Klauseln, so wird ein optimaler Stundenplan erzeugt, welcher in
   Abbildung [[ref:fig:with-optimisation-class-1]] und Abbildung
   [[ref:fig:with-optimisation-class-2]] dargestellt ist.

   #+CAPTION: Stundenplan für Klasse 1 mit Optimierung.
   #+LABEL: fig:with-optimisation-class-1
   #+ATTR_LaTeX: :width 200px
   [[/home/kima/programming/timetabling/images/hard-problem-with-optimisation-example-with-optimisation-class-1.png]]

   #+CAPTION: Stundenplan für Klasse 2 mit Optimierung.
   #+LABEL: fig:with-optimisation-class-2
   #+ATTR_LaTeX: :width 200px
   [[/home/kima/programming/timetabling/images/hard-problem-with-optimisation-example-with-optimisation-class-2.png]]

   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
        (def example-ents-optimal-room-scheduling-with-optimisation
          {:classes {:class-1 {}, :class-2 {}}, :teachers {:teacher-1 {}}, :buildings {:building-1 {:room-1 {}}, :building-2 {:room-1 {}}}, :distances {[:building-2 :building-1] 1, [:building-1 :building-2] 1}, :num-days 1, :hours-per-day 3, :events {:class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-1]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :forbidden-rooms #{}, :times [[0 2] [0 1]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :forbidden-rooms #{}, :times [[0 1] [0 2]]}}})
   #+end_src

   Dieser Stundenplan ist optimal, da bei ihm keine der beiden Klassen
   das Gebäude wechseln muss und ebenso keine Lücke zwischen
   Veranstaltungen hat.

   Abbildung [[ref:fig:cool]] zeigt einen Ausschnitt des Stundenplans von Klasse 1
   beim größeren Beispielproblem, welches mit den
   Optimalitätsbedingungen dem Open-wbo Weighted Partial MAX-SAT
   Solver für 2 Minuten übergeben wurde. Bei der von ihm zuletzt
   gefundenen Lösung beträgt die Summe der Gewichte der weichen
   Klauseln 180. In den drei dargestellten Tagen für Klasse 1 befindet
   sich weder ein Gebäudewechsel noch eine Lücke zwischen
   Veranstaltungen.

   #+CAPTION: Auszug des Stundenplanes für Klasse 1 bei Optimierung der Raumbelegung.
   #+LABEL: fig:cool
   #+ATTR_LaTeX: :width 400px
   [[/home/kima/programming/timetabling/images/bigger-example-entities-hard-problem-with-optimisation-class-1.png]]

   #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
     (def optimal-room-scheduling-bigger-example-entities-results
       {:events {:class-9-werken {:classes #{:class-9}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-9} #{:teacher-9}], :durations [1 1], :forbidden-rooms #{}, :times [[4 5] [0 1]]}, :class-2-werken {:classes #{:class-2}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :forbidden-rooms #{}, :times [[4 2] [3 0]]}, :class-10-sport {:classes #{:class-10}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[4 0]]}, :class-5-art {:classes #{:class-5}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-5} #{:teacher-5}], :durations [1 1], :forbidden-rooms #{}, :times [[0 2] [0 1]]}, :class-3-german {:classes #{:class-3}, :rooms [#{[:building-2 :room-3]} #{[:building-2 :room-6]} #{[:building-1 :room-3]} #{[:building-2 :room-6]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 1] [1 3] [2 5] [0 2]]}, :class-7-werken {:classes #{:class-7}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-7} #{:teacher-7}], :durations [1 1], :forbidden-rooms #{}, :times [[1 0] [4 4]]}, :class-3-math {:classes #{:class-3}, :rooms [#{[:building-2 :room-3]} #{[:building-1 :room-5]} #{[:building-1 :room-4]} #{[:building-2 :room-2]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 0] [2 2] [4 0] [1 4]]}, :class-2-art {:classes #{:class-2}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-2} #{:teacher-2}], :durations [1 1], :forbidden-rooms #{}, :times [[1 2] [1 5]]}, :class-3-werken {:classes #{:class-3}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-3} #{:teacher-3}], :durations [1 1], :forbidden-rooms #{}, :times [[0 0] [0 3]]}, :class-1-sk {:classes #{:class-1}, :rooms [#{[:building-1 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-6]} #{[:building-2 :room-2]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 0] [4 0] [4 4] [4 3]]}, :class-8-math {:classes #{:class-8}, :rooms [#{[:building-2 :room-6]} #{[:building-1 :room-4]} #{[:building-2 :room-1]} #{[:building-1 :room-4]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 2] [2 2] [4 4] [2 4]]}, :class-1-art {:classes #{:class-1}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :forbidden-rooms #{}, :times [[1 1] [1 3]]}, :class-6-werken {:classes #{:class-6}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-6} #{:teacher-6}], :durations [1 1], :forbidden-rooms #{}, :times [[0 5] [0 2]]}, :class-10-art {:classes #{:class-10}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-10} #{:teacher-10}], :durations [1 1], :forbidden-rooms #{}, :times [[0 4] [0 3]]}, :class-9-sport {:classes #{:class-9}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[2 0]]}, :class-12-art {:classes #{:class-12}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-12} #{:teacher-12}], :durations [1 1], :forbidden-rooms #{}, :times [[0 0] [1 0]]}, :class-1-sport {:classes #{:class-1}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[2 4]]}, :class-9-art {:classes #{:class-9}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-9} #{:teacher-9}], :durations [1 1], :forbidden-rooms #{}, :times [[3 1] [3 3]]}, :class-10-werken {:classes #{:class-10}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-10} #{:teacher-10}], :durations [1 1], :forbidden-rooms #{}, :times [[1 3] [1 4]]}, :class-8-sport {:classes #{:class-8}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[0 2]]}, :class-3-sk {:classes #{:class-3}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-3]} #{[:building-2 :room-2]} #{[:building-1 :room-6]}], :teachers [#{:teacher-3} #{:teacher-3} #{:teacher-3} #{:teacher-3}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 1] [0 5] [1 2] [4 3]]}, :class-11-werken {:classes #{:class-11}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-11} #{:teacher-11}], :durations [1 1], :forbidden-rooms #{}, :times [[3 5] [1 2]]}, :class-7-math {:classes #{:class-7}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-1]} #{[:building-1 :room-3]} #{[:building-2 :room-6]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 3] [4 3] [2 4] [1 5]]}, :class-8-art {:classes #{:class-8}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-8} #{:teacher-8}], :durations [1 1], :forbidden-rooms #{}, :times [[2 3] [3 5]]}, :class-4-art {:classes #{:class-4}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-4} #{:teacher-4}], :durations [1 1], :forbidden-rooms #{}, :times [[3 2] [3 0]]}, :class-7-german {:classes #{:class-7}, :rooms [#{[:building-2 :room-1]} #{[:building-1 :room-3]} #{[:building-2 :room-5]} #{[:building-2 :room-4]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 0] [2 0] [4 1] [4 5]]}, :class-6-sport {:classes #{:class-6}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[1 4]]}, :class-11-sport {:classes #{:class-11}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[4 4]]}, :class-2-german {:classes #{:class-2}, :rooms [#{[:building-1 :room-1]} #{[:building-2 :room-3]} #{[:building-1 :room-5]} #{[:building-1 :room-2]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 0] [3 5] [1 4] [2 4]]}, :class-7-art {:classes #{:class-7}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-7} #{:teacher-7}], :durations [1 1], :forbidden-rooms #{}, :times [[3 4] [2 5]]}, :class-4-math {:classes #{:class-4}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-5]} #{[:building-2 :room-3]} #{[:building-1 :room-2]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 4] [2 3] [4 4] [3 3]]}, :class-6-german {:classes #{:class-6}, :rooms [#{[:building-2 :room-6]} #{[:building-1 :room-3]} #{[:building-1 :room-4]} #{[:building-1 :room-3]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 3] [3 4] [4 2] [3 5]]}, :class-4-german {:classes #{:class-4}, :rooms [#{[:building-1 :room-5]} #{[:building-1 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-4]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 1] [2 2] [4 5] [0 5]]}, :class-1-german {:classes #{:class-1}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-3]} #{[:building-2 :room-1]} #{[:building-1 :room-3]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 5] [1 4] [3 1] [0 4]]}, :class-11-math {:classes #{:class-11}, :rooms [#{[:building-1 :room-1]} #{[:building-1 :room-6]} #{[:building-2 :room-1]} #{[:building-2 :room-6]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 4] [2 3] [1 5] [3 4]]}, :class-11-art {:classes #{:class-11}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-11} #{:teacher-11}], :durations [1 1], :forbidden-rooms #{}, :times [[2 0] [2 2]]}, :class-2-math {:classes #{:class-2}, :rooms [#{[:building-2 :room-6]} #{[:building-1 :room-2]} #{[:building-2 :room-1]} #{[:building-2 :room-3]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 1] [1 3] [3 4] [4 5]]}, :class-12-werken {:classes #{:class-12}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-12} #{:teacher-12}], :durations [1 1], :forbidden-rooms #{}, :times [[3 1] [2 5]]}, :class-6-sk {:classes #{:class-6}, :rooms [#{[:building-2 :room-6]} #{[:building-1 :room-3]} #{[:building-1 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 5] [4 0] [3 0] [0 0]]}, :class-4-sport {:classes #{:class-4}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[1 0]]}, :class-11-sk {:classes #{:class-11}, :rooms [#{[:building-2 :room-2]} #{[:building-2 :room-6]} #{[:building-2 :room-5]} #{[:building-1 :room-2]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 0] [3 3] [3 1] [2 1]]}, :class-2-sport {:classes #{:class-2}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[0 4]]}, :class-2-sk {:classes #{:class-2}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-2]} #{[:building-1 :room-1]} #{[:building-2 :room-1]}], :teachers [#{:teacher-2} #{:teacher-2} #{:teacher-2} #{:teacher-2}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 3] [4 4] [2 5] [3 2]]}, :class-8-werken {:classes #{:class-8}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-8} #{:teacher-8}], :durations [1 1], :forbidden-rooms #{}, :times [[4 3] [1 5]]}, :class-5-werken {:classes #{:class-5}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-5} #{:teacher-5}], :durations [1 1], :forbidden-rooms #{}, :times [[2 3] [2 2]]}, :class-12-sk {:classes #{:class-12}, :rooms [#{[:building-2 :room-6]} #{[:building-2 :room-1]} #{[:building-1 :room-3]} #{[:building-2 :room-5]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 4] [3 0] [0 1] [2 3]]}, :class-3-sport {:classes #{:class-3}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[3 4]]}, :class-7-sport {:classes #{:class-7}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[0 0]]}, :class-12-math {:classes #{:class-12}, :rooms [#{[:building-1 :room-3]} #{[:building-2 :room-1]} #{[:building-2 :room-2]} #{[:building-1 :room-5]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 3] [2 2] [3 4] [0 3]]}, :class-4-werken {:classes #{:class-4}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-4} #{:teacher-4}], :durations [1 1], :forbidden-rooms #{}, :times [[4 0] [0 4]]}, :class-10-math {:classes #{:class-10}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-5]} #{[:building-2 :room-5]} #{[:building-2 :room-2]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 0] [2 4] [3 2] [3 5]]}, :class-5-sk {:classes #{:class-5}, :rooms [#{[:building-2 :room-4]} #{[:building-1 :room-2]} #{[:building-1 :room-5]} #{[:building-1 :room-6]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 4] [4 2] [0 5] [0 0]]}, :class-9-german {:classes #{:class-9}, :rooms [#{[:building-2 :room-5]} #{[:building-1 :room-2]} #{[:building-1 :room-3]} #{[:building-1 :room-3]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 0] [1 0] [3 0] [1 1]]}, :class-3-art {:classes #{:class-3}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-3} #{:teacher-3}], :durations [1 1], :forbidden-rooms #{}, :times [[4 2] [2 4]]}, :class-9-sk {:classes #{:class-9}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-4]} #{[:building-1 :room-6]} #{[:building-1 :room-1]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 5] [4 3] [1 4] [1 5]]}, :class-11-german {:classes #{:class-11}, :rooms [#{[:building-1 :room-6]} #{[:building-1 :room-4]} #{[:building-1 :room-6]} #{[:building-2 :room-6]}], :teachers [#{:teacher-11} #{:teacher-11} #{:teacher-11} #{:teacher-11}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[2 5] [0 3] [0 5] [3 2]]}, :class-4-sk {:classes #{:class-4}, :rooms [#{[:building-1 :room-2]} #{[:building-1 :room-2]} #{[:building-2 :room-1]} #{[:building-2 :room-4]}], :teachers [#{:teacher-4} #{:teacher-4} #{:teacher-4} #{:teacher-4}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 5] [3 4] [0 2] [4 2]]}, :class-5-sport {:classes #{:class-5}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[3 0]]}, :class-6-art {:classes #{:class-6}, :rooms [#{[:building-1 :art-room]} #{[:building-1 :art-room]}], :teachers [#{:teacher-6} #{:teacher-6}], :durations [1 1], :forbidden-rooms #{}, :times [[4 3] [4 5]]}, :class-9-math {:classes #{:class-9}, :rooms [#{[:building-2 :room-3]} #{[:building-2 :room-2]} #{[:building-2 :room-1]} #{[:building-2 :room-6]}], :teachers [#{:teacher-9} #{:teacher-9} #{:teacher-9} #{:teacher-9}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 0] [0 4] [4 2] [4 1]]}, :class-8-german {:classes #{:class-8}, :rooms [#{[:building-2 :room-5]} #{[:building-1 :room-4]} #{[:building-2 :room-3]} #{[:building-1 :room-5]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 5] [2 1] [1 1] [2 5]]}, :class-1-werken {:classes #{:class-1}, :rooms [#{[:building-2 :werkraum]} #{[:building-2 :werkraum]}], :teachers [#{:teacher-1} #{:teacher-1}], :durations [1 1], :forbidden-rooms #{}, :times [[3 3] [4 1]]}, :class-5-math {:classes #{:class-5}, :rooms [#{[:building-1 :room-6]} #{[:building-2 :room-5]} #{[:building-2 :room-2]} #{[:building-1 :room-6]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 4] [2 4] [1 5] [4 0]]}, :class-10-german {:classes #{:class-10}, :rooms [#{[:building-2 :room-1]} #{[:building-1 :room-4]} #{[:building-2 :room-4]} #{[:building-2 :room-4]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[3 3] [2 5] [1 5] [3 4]]}, :class-7-sk {:classes #{:class-7}, :rooms [#{[:building-2 :room-5]} #{[:building-2 :room-4]} #{[:building-1 :room-6]} #{[:building-2 :room-3]}], :teachers [#{:teacher-7} #{:teacher-7} #{:teacher-7} #{:teacher-7}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 2] [1 2] [2 1] [1 4]]}, :class-1-math {:classes #{:class-1}, :rooms [#{[:building-1 :room-4]} #{[:building-2 :room-1]} #{[:building-2 :room-5]} #{[:building-1 :room-6]}], :teachers [#{:teacher-1} #{:teacher-1} #{:teacher-1} #{:teacher-1}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 2] [3 5] [3 0] [1 5]]}, :class-12-german {:classes #{:class-12}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-1]} #{[:building-2 :room-6]} #{[:building-2 :room-5]}], :teachers [#{:teacher-12} #{:teacher-12} #{:teacher-12} #{:teacher-12}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 5] [1 4] [2 0] [3 5]]}, :class-6-math {:classes #{:class-6}, :rooms [#{[:building-1 :room-4]} #{[:building-2 :room-4]} #{[:building-1 :room-1]} #{[:building-1 :room-6]}], :teachers [#{:teacher-6} #{:teacher-6} #{:teacher-6} #{:teacher-6}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[4 4] [0 4] [4 1] [3 1]]}, :class-5-german {:classes #{:class-5}, :rooms [#{[:building-1 :room-6]} #{[:building-2 :room-5]} #{[:building-2 :room-6]} #{[:building-1 :room-4]}], :teachers [#{:teacher-5} #{:teacher-5} #{:teacher-5} #{:teacher-5}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 3] [2 0] [2 1] [4 1]]}, :class-8-sk {:classes #{:class-8}, :rooms [#{[:building-2 :room-1]} #{[:building-2 :room-1]} #{[:building-2 :room-2]} #{[:building-2 :room-6]}], :teachers [#{:teacher-8} #{:teacher-8} #{:teacher-8} #{:teacher-8}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[1 3] [1 4] [1 0] [4 2]]}, :class-12-sport {:classes #{:class-12}, :rooms [#{[:sporthalle :sporthalle]}], :teachers [#{:sportlehrer}], :durations [2], :forbidden-rooms #{}, :times [[4 2]]}, :class-10-sk {:classes #{:class-10}, :rooms [#{[:building-1 :room-3]} #{[:building-1 :room-1]} #{[:building-2 :room-4]} #{[:building-1 :room-1]}], :teachers [#{:teacher-10} #{:teacher-10} #{:teacher-10} #{:teacher-10}], :durations [1 1 1 1], :forbidden-rooms #{[:building-1 :art-room] [:sporthalle :sporthalle] [:building-2 :werkraum]}, :times [[0 2] [0 5] [3 1] [2 3]]}}, :hours-per-day 6, :num-days 5, :distances {[:building-1 :sporthalle] 1, [:sporthalle :building-2] 1, [:sporthalle :building-1] 1, [:building-2 :sporthalle] 1, [:building-2 :building-1] 1, [:building-1 :building-2] 1}, :buildings {:building-1 {:room-1 {}, :room-2 {}, :room-3 {}, :room-4 {}, :room-5 {}, :room-6 {}, :art-room {}}, :building-2 {:room-1 {}, :room-2 {}, :room-3 {}, :room-4 {}, :room-5 {}, :room-6 {}, :werkraum {}}, :sporthalle {:sporthalle {}}}, :teachers {:teacher-7 {}, :teacher-6 {}, :teacher-10 {}, :teacher-1 {}, :teacher-11 {}, :sportlehrer {}, :teacher-4 {}, :teacher-2 {}, :teacher-12 {}, :teacher-8 {}, :teacher-3 {}, :teacher-5 {}, :teacher-9 {}}, :classes {:class-4 {:class-teacher :teacher-4, :class-room [:building-2 :room-2]}, :class-10 {:class-teacher :teacher-10, :class-room [:building-2 :room-5]}, :class-11 {:class-teacher :teacher-11, :class-room [:building-1 :room-6]}, :class-8 {:class-teacher :teacher-8, :class-room [:building-2 :room-4]}, :class-2 {:class-teacher :teacher-2, :class-room [:building-2 :room-1]}, :class-12 {:class-teacher :teacher-12, :class-room [:building-2 :room-6]}, :class-3 {:class-teacher :teacher-3, :class-room [:building-1 :room-2]}, :class-5 {:class-teacher :teacher-5, :class-room [:building-1 :room-3]}, :class-1 {:class-teacher :teacher-1, :class-room [:building-1 :room-1]}, :class-7 {:class-teacher :teacher-7, :class-room [:building-1 :room-4]}, :class-6 {:class-teacher :teacher-6, :class-room [:building-2 :room-3]}, :class-9 {:class-teacher :teacher-9, :class-room [:building-1 :room-5]}}})
   #+end_src

*** Untersuchung der Skalierbarkeit
    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (defn create-scalable-optimizeable-room-scheduling-problem [num-hours num-days num-classes]
        (let [num-slots (* num-days num-hours)]
          {:classes (reduce #(assoc %1 (keyword (str "class-" %2))
                                    {:class-teacher (keyword (str "teacher-" %2))
                                     :class-room [(keyword (str "building-" %2)) :room-1]})
                            {} (range num-classes))
           :teachers (reduce #(assoc %1 (keyword (str "teacher-" %2)) {}) {} (range num-classes))
           :distances {}
           :num-days num-days
           :hours-per-day num-hours
           :buildings (reduce #(assoc %1 (keyword (str "building-" %2)) {:room-1 {}})
                              {} (range num-classes))
           :events (reduce #(assoc %1 (keyword (str "ef-" %2))
                                   (create-event :classes (keyword (str "class-" %2))
                                                 :teachers #{(keyword (str "teacher-" %2))}
                                                 :number-of-times (dec num-slots)))
                           {} (range num-classes))}))
    #+end_src

    Zusätzlich zu der beschriebenen Anpassung des skalierbaren
    Problems für die Situation, in der auch die Raumplanung vom Solver
    vorgenommen wird, hat hier, wie bei der Erzeugung eines optimalen
    Stundenplan beim einfacheren Teilproblem, jede Klasse nur 34
    Veranstaltungen in der Woche, sodass für einen optimalen
    Stundenplan die freie Stunde im Stundenplan jeder Klasse und jeden
    Lehrers auf eine erste oder letzte Stunde eines Tages gelegt
    werden muss.

    #+CAPTION: Anzahl erzeugter Klauseln und Laufzeit des Solvers bei unterschiedlicher Klassenzahl
    #+NAME: tab:scalable-room-scheduling-optimal
    | Klassen | Klauseln | Zeit Lösung | Gewicht |
    |---------+----------+-------------+---------|
    |       1 |    95421 | 0,5         |       0 |
    |       2 |   217878 | 1,1         |       0 |
    |       4 |   545260 | 12,5        |       0 |
    |       6 |   988266 | 55,2        |       0 |
    |       8 |  1533432 | 92,8        |       0 |
    |      10 |  2231350 | TIMEOUT     |      12 |
    |      12 |  3001236 | TIMEOUT     |      22 |

    Bis zur Eingabegröße 8 konnte innerhalb von 5 Minuten ein
    optimaler Stundenplan generiert werden. Bei 12 Klassen konnte in
    der vorgegebenen Zeit nicht mehr das Optimum gefunden werden,
    dafür aber eine zulässige Lösung, welche eine Gewichtung von 22
    aufweist. Bei der Eingabgegröße 20 wurde nach 5 Minuten keine
    zulässige Lösung gefunden.



* CANCELLED Auch Zuweisung der Lehrer nicht bekannt                :noexport:
  CLOSED: [2015-07-07 Tue 09:49]
  :PROPERTIES:
  :ID:       1897928d-89ac-4f27-9e1a-0b281e2d4601
  :END:

* Diskussion der Ergebnisse und Ausblick
  In dieser Arbeit wurden mit dem Ansatz, das Stundenplanproblem in ein
  SAT, bzw Weighted Partial MAX-SAT Problem zu übersetzen, zulässige,
  bzw. möglichst optimale Stundenpläne für Probleme aufsteigender
  Komplexität erzeugt.

  Zuerst wurde ein vereinfachtes Problem betrachtet, in dem schon alle
  Räume der Events feststanden und nur noch die Zeiten der Events
  geplant werden mussten. Dieses Problem wurde ebenfalls in zwei Unterprobleme
  unterteilt, einmal die Erzeugung eines /zulässigen/ Stundenplans,
  und darauf aufbauend die Erzeugung eines hinsichtlich Lücken
  zwischen Veranstaltungen und Wechsel zwischen entfernten Gebäuden
  möglichst /optimalen/ Stundenplans.

  Danach wurde dieses Teilproblem erweitert, in dem zusätzlich
  zu den Zeiten der Events, auch deren Räume gesucht wurden. Auch hier
  wurde eine Unterteilung in die Erzeugung von zulässigem und
  optimalem Stundenplan vorgenommen.

  Jede Stufe wurde mit einfachen Beispielproblemen untersucht und an
  einem selbst geschriebenen größeren Beispiel von für einer
  zwölfzügigen Grundschule realistischer Größe getestet.

  Mit diesem Beispielprogramm konnten in jeder Stufe gute Ergebnisse
  erzielt werden.In nur zwei Minuten hat der Open-wbo Solver für das
  größere Beispielproblem bei der erweiterten Problemstellung eine
  erste zulässige Lösung gefunden, bei der die Summe der Gewichte 1588
  betrug und diese auf 180 optimiert.

  Die Skalierbarkeit des Ansatzes wurde für alle Stufen anhand eines
  skalierbaren Beispielproblems analysiert, bei dem für die
  vorgegebene Anzahl von Klassen die maximal mögliche Anzahl von
  Events gefordert wurde, damit das Problem lösbar bleibt. Das
  vereinfachte Teilproblem konnte auf ein auf 100 Klassen skaliertes
  Problem in 15 Minuten gelöst werden. Bei dem erweiterten Problem
  wurden schon zum Lösen des auf 12 Klassen skalierten Problems fast 9
  Minuten gebraucht und das auf 20 Klassen skalierte Problem konnte
  nicht innerhalb von 20 Stunden gelöst werden.

  Das Praktische an diesem vorgestellen Ansatz ist, dass das
  Stundenplanproblem durch Reduzierung auf ein Weighted Partial
  MAX-SAT Problem mit sehr effizienten und lange optimierten Solvern
  gelöst werden kann. Dadurch wird das Problem, den diesem Problem
  zugrunde liegenden Suchbaum möglichst effektiv zu durchlaufen,
  abgegeben.

  Das Programm konnte allerdings nicht an den echten Daten der
  Grundschule Oslebshausen getestet werden, da keine anonymisierten
  Daten zur Verfügung gestellt werden konnten. Daher kann keine
  definitive Aussage getroffen werden, ob das hier entwickelte
  Programm einen guten Stundenplan für diese Grundschule generieren
  kann.

  Mit dieser Bachelorarbeit ist das Thema noch nicht abgschlossen:
  - Es könnten in Zukunft noch mehr Optimalitätsbedingungen gestellt
    werden. Beispiele wären die Vermeidung von sehr kurzen Tagen für
    eine Klasse bzw. einen Lehrer, eine gewisse /Rhytmisierung/ des
    Unterrichts einer Klasse (zum Beispiel nicht zwei schwere
    Mathestunden hintereinander).
  - Das Programm geht davon aus, dass die Zuordnung, welche Lehrer
    welche Veranstaltungen einer Klasse unterrichtet, bekannt ist.
    Sollte dies nicht der Fall sein, müsste das Programm auf diesen
    Fall noch angepasst werden. Konzeptionell ist das ähnlich der
    Anpassung auf die Situation, dass auch Räume verplant werden
    müssen, bei der die Beziehung $\operatorname{rooms}$ weggefallen
    ist, und es müssten alle Bedingungen angepasst werden, bei deren
    Kodierung in aussagenlogische Klauseln von der Beziehung
    $\operatorname{teachers}$ Gebrauch gemacht wird. Außerdem müssten
    neue Bedingungen an einen zulässigen Stundenplan gestellt werden,
    wie die Einhaltung von Minimal- und Maximalwochenstunden der
    Lehrpersonen. Dieses könnte zum Beispiel mittels
    Kardinalitätsklauseln zu aussagenlogischen Klauseln übersetzt
    werden.

  Schließlich wäre es auch wünschenswert, diesen Ansatz mit anderen
  Ansätzen zur automatischen Stundenplanerzeugung, wie zum Beispiel
  genetischen Algorithmen, für dieses spezielle Problem zu
  vergleichen, was im Rahmen dieser Arbeit aus Zeitgründen nicht
  möglich war. Dieses könnte ein Thema für eine zukünftige
  Masterarbeit sein.


    #+begin_src clojure :ns timetabling.core :tangle src/timetabling/core.clj
      (deftest test-solves
        (is (not (nil? (solve-problem example-entities))))
        (is (not (nil? (solve-problem bigger-example-entities)))))
    #+end_src
[[bibliographystyle:plain]]
[[bibliography:/home/kima/Dropbox/emacs/bibliography/references.bib]]
\addcontentsline{toc}{chapter}{Literaturverzeichnis}

\clearpage

\chapter*{Anhang}

  In der Beigelegten CD findet sich diese Arbeit in elektronischer
  Form sowie das entwickelte Programm zusammen mit einer Anleitung.
